#!/bin/sh

version_number="4.10.4"

# PROVIDER CONFIGURATION
provider="${ANI_CLI_PROVIDER:-}"  # netflix or allanime

# Netflix Mirror Configuration
netflix_main="https://net20.cc"
netflix_new="https://net51.cc"
netflix_cookie=""

# JioHotstar Configuration
jiohotstar_main="https://net20.cc"
jiohotstar_new="https://net51.cc"
jiohotstar_cookie=""

# PrimeVideo Configuration
primevideo_main="https://net20.cc"
primevideo_new="https://net51.cc"
primevideo_cookie=""

# HiAnime Configuration
hianime_base="https://hianime.to"
hianime_ajax="https://hianime.to/ajax/v2"
megacloud_api="https://crawlr.cc/9D7F1B3E8"
hianime_sub_or_dub="sub"  # sub or dub preference

# AnimePahe Configuration
animepahe_base="https://animepahe.si"
animepahe_kwik_base="https://kwik.cx"

# UI

external_menu() {
    rofi "$1" -sort -dmenu -i -width 1500 -p "$2" "$3"
}

launcher() {
    [ "$use_external_menu" = "0" ] && [ -z "$1" ] && set -- "+m" "$2"
    [ "$use_external_menu" = "0" ] && fzf "$1" --reverse --cycle --prompt "$2"
    [ "$use_external_menu" = "1" ] && external_menu "$1" "$2" "$external_menu_args"
}

nth() {
    stdin=$(cat -)
    [ -z "$stdin" ] && return 1
    line_count="$(printf "%s\n" "$stdin" | wc -l | tr -d "[:space:]")"
    [ "$line_count" -eq 1 ] && printf "%s" "$stdin" | cut -f2,3 && return 0
    prompt="$1"
    multi_flag=""
    [ $# -ne 1 ] && shift && multi_flag="$1"
    line=$(printf "%s" "$stdin" | cut -f1,3 | tr '\t' ' ' | launcher "$multi_flag" "$prompt" | cut -d " " -f 1)
    line_start=$(printf "%s" "$line" | head -n1)
    line_end=$(printf "%s" "$line" | tail -n1)
    [ -n "$line" ] || exit 1
    if [ "$line_start" = "$line_end" ]; then
        printf "%s" "$stdin" | grep -E '^'"${line}"'($|[[:space:]])' | cut -f2,3 || exit 1
    else
        printf "%s" "$stdin" | sed -n '/^'"${line_start}"'$/,/^'"${line_end}$"'/p' || exit 1
    fi
}

die() {
    printf "\33[2K\r\033[1;31m%s\033[0m\n" "$*" >&2
    exit 1
}

# Debug logging function
debug_log() {
    [ "$debug_mode" = "1" ] && printf "\033[1;35m[DEBUG]\033[0m %s\n" "$*" >&2
}

help_info() {
    printf "
    Usage:
    %s [options] [query]
    %s [query] [options]
    %s [options] [query] [options]

    Options:
      -c, --continue
        Continue watching from history
      -d, --download
        Download the video instead of playing it
      -D, --delete
        Delete history
      -l, --logview
        Show logs
      -s, --syncplay
        Use Syncplay to watch with friends
      -S, --select-nth
        Select nth entry
      -q, --quality
        Specify the video quality
      -v, --vlc
        Use VLC to play the video
      -V, --version
        Show the version of the script
      -h, --help
        Show this help message and exit
      -e, --episode, -r, --range
        Specify the number of episodes to watch
      --dub
        Play dubbed version
      --sub
        Play subbed version (default for HiAnime)
      --rofi
        Use rofi instead of fzf for the interactive menu
      --skip
        Use ani-skip to skip the intro of the episode (mpv only)
      --no-detach
        Don't detach the player (useful for in-terminal playback, mpv only)
      --exit-after-play
        Exit the player, and return the player exit code (useful for non interactive scenarios, mpv only)
      --skip-title <title>
        Use given title as ani-skip query
      -N, --nextep-countdown
        Display a countdown to the next episode
      -U, --update
        Update the script
      --netflix
        Use Netflix Mirror as the provider
      --allanime
        Use AllAnime as the provider (default)
      --jiohotstar
        Use JioHotstar (Mirror) as the provider
      --primevideo
        Use PrimeVideo (Mirror) as the provider
      --hianime
        Use HiAnime as the provider (anime)
      --animepahe
        Use AnimePahe as the provider (anime)
      --global
        Use Global Search (search all providers at once)
      --debug
        Enable verbose debug mode (shows API responses and URLs)
    Some example usages:
      %s -q 720p banana fish
      %s --skip --skip-title \"one piece\" -S 2 one piece
      %s -d -e 2 cyberpunk edgerunners
      %s --vlc cyberpunk edgerunners -q 1080p -e 4
      %s blue lock -e 5-6
      %s -e \"5 6\" blue lock
    \n" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}"
    exit 0
}

version_info() {
    printf "%s\n" "$version_number"
    exit 0
}

update_script() {
    update="$(curl -s -A "$agent" "https://raw.githubusercontent.com/pystardust/ani-cli/master/ani-cli")" || die "Connection error"
    update="$(printf '%s\n' "$update" | diff -u "$0" -)"
    if [ -z "$update" ]; then
        printf "Script is up to date :)\n"
    else
        if printf '%s\n' "$update" | patch "$0" -; then
            printf "Script has been updated\n"
        else
            die "Can't update for some reason!"
        fi
    fi
    exit 0
}

# NETFLIX MIRROR FUNCTIONS

netflix_bypass() {
    cookie_file="$hist_dir/netflix_cookie"
    # Check if cached cookie exists and is less than 15 hours old (54000 seconds)
    if [ -f "$cookie_file" ]; then
        cookie_age=$(($(date +%s) - $(stat -c %Y "$cookie_file" 2>/dev/null || stat -f %m "$cookie_file" 2>/dev/null || echo 0)))
        if [ "$cookie_age" -lt 54000 ]; then
            netflix_cookie=$(cat "$cookie_file")
            debug_log "Using cached Netflix cookie"
            [ -n "$netflix_cookie" ] && return 0
        fi
    fi
    
    debug_log "Getting new Netflix cookie from $netflix_main/tv/p.php"
    printf "\33[2K\r\033[1;34mBypassing Netflix protection...\033[0m\n" >&2
    max_attempts=10
    attempt=0
    while [ "$attempt" -lt "$max_attempts" ]; do
        # Get cookie from Set-Cookie header
        response=$(curl -s -X POST "$netflix_main/tv/p.php" -A "$agent" -D - 2>/dev/null)
        debug_log "Bypass attempt $((attempt + 1)): response status=$(printf '%s' \"$response\" | head -1)"
        if printf "%s" "$response" | grep -q '"r":"n"'; then
            # Extract the full cookie value including URL-encoded parts
            netflix_cookie=$(printf "%s" "$response" | grep -i 'set-cookie.*t_hash_t=' | sed -nE 's/.*t_hash_t=([^;]+);.*/\1/p' | head -1)
            debug_log "Extracted cookie: $netflix_cookie"
            if [ -n "$netflix_cookie" ]; then
                printf "%s" "$netflix_cookie" > "$cookie_file"
                printf "\33[2K\r\033[1;32mNetflix bypass successful!\033[0m\n" >&2
                return 0
            fi
        fi
        attempt=$((attempt + 1))
        sleep 1
    done
    die "Failed to bypass Netflix protection after $max_attempts attempts"
}

netflix_search() {
    netflix_bypass
    timestamp=$(date +%s)
    printf "\33[2K\r\033[1;34mSearching Netflix...\033[0m\n" >&2
    search_url="$netflix_main/search.php?s=$1&t=$timestamp"
    debug_log "Search URL: $search_url"
    search_result=$(curl -s "$search_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$netflix_cookie; hd=on; ott=nf" \
        -H "Referer: $netflix_main/tv/home" \
        -A "$agent")
    debug_log "Search response: $search_result"
    # Parse JSON response - format: id<tab>title
    printf "%s" "$search_result" | sed 's/},{/\n/g' | sed -nE 's/.*"id":"([^"]+)".*"t":"([^"]+)".*/\1\t\2/p'
}

netflix_load_cookie() {
    cookie_file="$hist_dir/netflix_cookie"
    [ -f "$cookie_file" ] && netflix_cookie=$(cat "$cookie_file")
}

netflix_get_details() {
    netflix_load_cookie
    timestamp=$(date +%s)
    details_url="$netflix_main/post.php?id=$1&t=$timestamp"
    debug_log "Getting details from: $details_url"
    result=$(curl -s "$details_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$netflix_cookie; hd=on; ott=nf" \
        -H "Referer: $netflix_main/tv/home" \
        -A "$agent")
    debug_log "Details response (first 500 chars): $(printf '%.500s' "$result")"
    printf "%s" "$result"
}

netflix_episodes_list() {
    netflix_load_cookie
    details=$(netflix_get_details "$1")
    debug_log "netflix_episodes_list: getting episodes for $1"
    # Check if it's a movie (no episodes)
    is_movie=$(printf "%s" "$details" | grep -o '"episodes":\[null\]')
    if [ -n "$is_movie" ]; then
        debug_log "Content is a movie, returning 1"
        printf "1\n"
        return
    fi
    
    # Extract all seasons info and generate episode list
    # Parse season data: extract season number and episode count
    season_info=$(printf "%s" "$details" | grep -oE '"season":\[[^]]*\]' | sed 's/"season":\[//;s/\]//' | sed 's/},{/\n/g')
    debug_log "Season info: $season_info"
    printf "%s\n" "$season_info" | while IFS= read -r season_data; do
        [ -z "$season_data" ] && continue
        s_num=$(printf "%s" "$season_data" | sed -nE 's/.*"s":"([^"]+)".*/\1/p')
        ep_count=$(printf "%s" "$season_data" | sed -nE 's/.*"ep":"([^"]+)".*/\1/p')
        
        if [ -n "$s_num" ] && [ -n "$ep_count" ]; then
            i=1
            while [ "$i" -le "$ep_count" ]; do
                printf "%s.%s\n" "$s_num" "$i"
                i=$((i + 1))
            done
        fi
    done
}

netflix_get_episode_id() {
    netflix_load_cookie
    debug_log "netflix_get_episode_id: id=$1, ep_no=$2"
    # For movies, return the show ID
    details=$(netflix_get_details "$1")
    is_movie=$(printf "%s" "$details" | grep -o '"episodes":\[null\]')
    if [ -n "$is_movie" ]; then
        debug_log "Content is a movie, returning show ID: $1"
        printf "%s" "$1"
        return
    fi
    
    target_ep="$2"
    # Handle format like "1.5" -> Season 1, Episode 5
    if printf "%s" "$target_ep" | grep -q '\.'; then
        target_season=$(printf "%s" "$target_ep" | cut -d'.' -f1)
        target_episode=$(printf "%s" "$target_ep" | cut -d'.' -f2)
    else
        # If just a number, assume season 1
        target_season="1"
        target_episode="$target_ep"
    fi
    debug_log "Target: Season $target_season, Episode $target_episode"
    
    # Get season ID for target season - use sed to extract directly
    season_id=$(printf "%s" "$details" | grep -oE '"season":\[[^]]*\]' | sed 's/"season":\[//;s/\]//' | sed 's/},{/\n/g' | sed -nE 's/.*"s":"'"$target_season"'".*"id":"([^"]+)".*/\1/p; s/.*"id":"([^"]+)".*"s":"'"$target_season"'".*/\1/p' | head -1)
    debug_log "Season ID: $season_id"
    
    [ -z "$season_id" ] && return 1
    
    # Fetch episodes for that season
    timestamp=$(date +%s)
    ep_url="$netflix_main/episodes.php?s=$season_id&series=$1&t=$timestamp&page=1"
    debug_log "Episodes URL: $ep_url"
    ep_response=$(curl -s "$ep_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$netflix_cookie; hd=on; ott=nf" \
        -H "Referer: $netflix_main/tv/home" \
        -A "$agent")
    debug_log "Episodes response (first 500 chars): $(printf '%.500s' "$ep_response")"
    
    # Find the episode ID matching our target episode number - use sed to extract directly
    ep_id=$(printf "%s" "$ep_response" | sed 's/},{/\n/g' | sed -nE 's/.*"ep":"'"$target_episode"'".*"id":"([^"]+)".*/\1/p; s/.*"id":"([^"]+)".*"ep":"'"$target_episode"'".*/\1/p' | head -1)
    debug_log "Found episode ID: $ep_id"
    printf "%s" "$ep_id"
}

netflix_get_episode_url() {
    netflix_load_cookie
    debug_log "netflix_get_episode_url: id=$id, ep_no=$ep_no"
    episode_id=$(netflix_get_episode_id "$id" "$ep_no")
    [ -z "$episode_id" ] && die "Episode not found!"
    debug_log "Got episode ID: $episode_id"
    
    cache_dir="$(mktemp -d)"
    timestamp=$(date +%s)
    playlist_url="$netflix_new/tv/playlist.php?id=$episode_id&t=$(printf '%s' "$allanime_title" | sed 's/ /%20/g')&tm=$timestamp"
    debug_log "Playlist URL: $playlist_url"
    
    response=$(curl -s "$playlist_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$netflix_cookie; hd=on; ott=nf" \
        -H "Referer: $netflix_main/home" \
        -A "$agent")
    
    # Store full response for audio/subtitle extraction
    netflix_playlist_response="$response"
    
    debug_log "Playlist response (first 1000 chars): $(printf '%.1000s' "$response")"
    
    # Extract sources section (before tracks)
    sources_section=$(printf "%s" "$response" | sed 's/"tracks":.*//')
    
    # Normalize JSON - remove newlines and extra spaces
    normalized=$(printf "%s" "$sources_section" | tr -d '\n\r\t' | sed 's/  */ /g')
    
    # Extract m3u8 URLs by splitting on },{ and processing each source
    # Format from API: {"file": "/tv/hls/ID.m3u8?...", "label": "Full HD", ...}
    links=""
    
    # Full HD (1080p) - no q= parameter means full quality
    full_hd=$(printf "%s" "$normalized" | grep -oE '"file"[^,]*m3u8\?in=[^"]*"[^}]*"label"[^}]*"Full HD"' | head -1)
    [ -z "$full_hd" ] && full_hd=$(printf "%s" "$normalized" | grep -oE '"label"[^}]*"Full HD"[^}]*"file"[^,]*m3u8[^"]*"' | head -1)
    if [ -n "$full_hd" ]; then
        url=$(printf "%s" "$full_hd" | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$url" ] && url=$(printf "%s" "$url" | sed 's|/tv/|/|') && links="1080p >${netflix_new}${url}"
    fi
    
    # Mid HD (720p) - has q=720p parameter
    mid_hd=$(printf "%s" "$normalized" | grep -oE '"file"[^,]*q=720p[^"]*"[^}]*"label"[^}]*"Mid HD"' | head -1)
    [ -z "$mid_hd" ] && mid_hd=$(printf "%s" "$normalized" | grep -oE '"label"[^}]*"Mid HD"[^}]*"file"[^,]*m3u8[^"]*"' | head -1)
    if [ -n "$mid_hd" ]; then
        url=$(printf "%s" "$mid_hd" | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$url" ] && url=$(printf "%s" "$url" | sed 's|/tv/|/|') && links="${links}
720p >${netflix_new}${url}"
    fi
    
    # Low HD (480p) - has q=480p parameter  
    low_hd=$(printf "%s" "$normalized" | grep -oE '"file"[^,]*q=480p[^"]*"[^}]*"label"[^}]*"Low HD"' | head -1)
    [ -z "$low_hd" ] && low_hd=$(printf "%s" "$normalized" | grep -oE '"label"[^}]*"Low HD"[^}]*"file"[^,]*m3u8[^"]*"' | head -1)
    if [ -n "$low_hd" ]; then
        url=$(printf "%s" "$low_hd" | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$url" ] && url=$(printf "%s" "$url" | sed 's|/tv/|/|') && links="${links}
480p >${netflix_new}${url}"
    fi
    
    # Remove leading newline if present
    links=$(printf "%s" "$links" | sed '/^$/d')
    
    debug_log "Extracted links:\n$links"
    
    # Extract English subtitle
    subtitle=$(printf "%s" "$response" | grep -oE '"kind":"captions"[^}]*"label":"English[^"]*"[^}]*"file":"[^"]*"' | head -1 | sed -nE 's/.*"file":"([^"]+)".*/\1/p' | sed 's|\\\/|/|g')
    [ -z "$subtitle" ] && subtitle=$(printf "%s" "$response" | grep -oE '"file":"[^"]*"[^}]*"label":"English[^"]*"[^}]*"kind":"captions"' | head -1 | sed -nE 's/.*"file":"([^"]+)".*/\1/p' | sed 's|\\\/|/|g')
    debug_log "Subtitle: $subtitle"
    
    if [ -n "$subtitle" ]; then
        # Build full subtitle URL - handle protocol-relative URLs (//domain/path)
        case "$subtitle" in
            http*) ;; # Already a full URL
            //*) subtitle="https:$subtitle" ;;
            /*) subtitle="https://subs.nfmirrorcdn.top$subtitle" ;;
        esac
        # Clean up any double slashes in path (but not after https:)
        subtitle=$(printf "%s" "$subtitle" | sed 's|\(https://[^/]*\)//*|\1/|g; s|/\{2,\}|/|g')
        subs_flag="--sub-file=$subtitle"
    fi
    
    # Set referrer and cookie header for CDN requests
    refr_flag="--referrer=${netflix_new}/ --http-header-fields=Cookie:\ hd=on"
    
    # Extract available subtitle languages from tracks with kind=captions
    # Filter out CC, forced, duplicates (1), and 2-letter language codes
    netflix_available_subs=$(printf "%s" "$response" | grep -oE '"kind":"captions"[^}]+' | sed -nE 's/.*"label":"([^"]+)".*/\1/p' | grep -v -iE '(\[CC\]|forced|\(1\))' | grep -vE '^[a-z]{2}$' | sort -u)
    
    select_quality "$quality"
    rm -r "$cache_dir" 2>/dev/null
    
    [ -z "$episode" ] && die "No valid sources found! Links: $links"
    
    # Store master m3u8 URL for audio track switching
    netflix_master_url="$episode"
    
    # Extract available audio languages from m3u8 (faster than yt-dlp -F)
    printf "\\33[2K\\r\\033[1;34mLoading audio tracks...\\033[0m\\n" >&2
    m3u8_content=$(curl -s "$netflix_master_url" -H "Referer: ${netflix_new}/" -H "Cookie: hd=on" -A "$agent" 2>/dev/null)
    netflix_available_audio=$(printf "%s" "$m3u8_content" | grep -oE 'NAME="[^"]+"' | cut -d'"' -f2 | grep -v "^$" | sort -u)
    [ -z "$netflix_available_audio" ] && netflix_available_audio="English"
    
    # Set default audio track (English)
    netflix_selected_audio="${netflix_selected_audio:-English}"
    netflix_audio_file="--alang=${netflix_selected_audio}"
    
    # Set referrer for playback
    refr_flag="--referrer=${netflix_new}/"
    
    debug_log "Available audio: $netflix_available_audio"
    debug_log "Available subtitles: $netflix_available_subs"
    debug_log "Video URL: $episode"
    debug_log "Selected audio: $netflix_selected_audio"
}

# JIOHOTSTAR FUNCTIONS

jiohotstar_bypass() {
    cookie_file="$hist_dir/jiohotstar_cookie"
    # Check if cached cookie exists and is less than 15 hours old (54000 seconds)
    if [ -f "$cookie_file" ]; then
        cookie_age=$(($(date +%s) - $(stat -c %Y "$cookie_file" 2>/dev/null || stat -f %m "$cookie_file" 2>/dev/null || echo 0)))
        if [ "$cookie_age" -lt 54000 ]; then
            jiohotstar_cookie=$(cat "$cookie_file")
            debug_log "Using cached JioHotstar cookie"
            [ -n "$jiohotstar_cookie" ] && return 0
        fi
    fi
    
    debug_log "Getting new JioHotstar cookie from $jiohotstar_main/tv/p.php"
    printf "\33[2K\r\033[1;34mBypassing JioHotstar (Mirror) protection...\033[0m\n" >&2
    max_attempts=10
    attempt=0
    while [ "$attempt" -lt "$max_attempts" ]; do
        response=$(curl -s -X POST "$jiohotstar_main/tv/p.php" -A "$agent" -D - 2>/dev/null)
        debug_log "Bypass attempt $((attempt + 1)): response status=$(printf '%s' \"$response\" | head -1)"
        if printf "%s" "$response" | grep -q '"r":"n"'; then
            jiohotstar_cookie=$(printf "%s" "$response" | grep -i 'set-cookie.*t_hash_t=' | sed -nE 's/.*t_hash_t=([^;]+);.*/\1/p' | head -1)
            debug_log "Extracted cookie: $jiohotstar_cookie"
            if [ -n "$jiohotstar_cookie" ]; then
                printf "%s" "$jiohotstar_cookie" > "$cookie_file"
                printf "\33[2K\r\033[1;32mJioHotstar (Mirror) bypass successful!\033[0m\n" >&2
                return 0
            fi
        fi
        attempt=$((attempt + 1))
        sleep 1
    done
    die "Failed to bypass JioHotstar (Mirror) protection after $max_attempts attempts"
}

jiohotstar_search() {
    jiohotstar_bypass
    timestamp=$(date +%s)
    printf "\33[2K\r\033[1;34mSearching JioHotstar (Mirror)...\033[0m\n" >&2
    search_url="$jiohotstar_main/mobile/hs/search.php?s=$1&t=$timestamp"
    debug_log "Search URL: $search_url"
    search_result=$(curl -s "$search_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$jiohotstar_cookie; hd=on; ott=hs" \
        -H "Referer: $jiohotstar_main/home" \
        -A "$agent")
    debug_log "Search response: $search_result"
    # Parse JSON response - format: id<tab>title
    printf "%s" "$search_result" | sed 's/},{/\n/g' | sed -nE 's/.*"id":"([^"]+)".*"t":"([^"]+)".*/\1\t\2/p'
}

jiohotstar_load_cookie() {
    cookie_file="$hist_dir/jiohotstar_cookie"
    [ -f "$cookie_file" ] && jiohotstar_cookie=$(cat "$cookie_file")
}

jiohotstar_get_details() {
    jiohotstar_load_cookie
    timestamp=$(date +%s)
    details_url="$jiohotstar_main/mobile/hs/post.php?id=$1&t=$timestamp"
    debug_log "Getting details from: $details_url"
    result=$(curl -s "$details_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$jiohotstar_cookie; hd=on; ott=hs" \
        -H "Referer: $jiohotstar_main/home" \
        -A "$agent")
    debug_log "Details response (first 500 chars): $(printf '%.500s' "$result")"
    printf "%s" "$result"
}

jiohotstar_episodes_list() {
    jiohotstar_load_cookie
    details=$(jiohotstar_get_details "$1")
    debug_log "jiohotstar_episodes_list: getting episodes for $1"
    # Check if it's a movie (no episodes)
    is_movie=$(printf "%s" "$details" | grep -o '"episodes":\[null\]')
    if [ -n "$is_movie" ]; then
        debug_log "Content is a movie, returning 1"
        printf "1\n"
        return
    fi
    
    # Extract all seasons info and generate episode list
    season_info=$(printf "%s" "$details" | grep -oE '"season":\[[^]]*\]' | sed 's/"season":\[//;s/\]//' | sed 's/},{/\n/g')
    debug_log "Season info: $season_info"
    printf "%s\n" "$season_info" | while IFS= read -r season_data; do
        [ -z "$season_data" ] && continue
        s_num=$(printf "%s" "$season_data" | sed -nE 's/.*"s":"([^"]+)".*/\1/p')
        ep_count=$(printf "%s" "$season_data" | sed -nE 's/.*"ep":"([^"]+)".*/\1/p')
        
        if [ -n "$s_num" ] && [ -n "$ep_count" ]; then
            i=1
            while [ "$i" -le "$ep_count" ]; do
                printf "%s.%s\n" "$s_num" "$i"
                i=$((i + 1))
            done
        fi
    done
}

jiohotstar_get_episode_id() {
    jiohotstar_load_cookie
    debug_log "jiohotstar_get_episode_id: id=$1, ep_no=$2"
    # For movies, return the show ID
    details=$(jiohotstar_get_details "$1")
    is_movie=$(printf "%s" "$details" | grep -o '"episodes":\[null\]')
    if [ -n "$is_movie" ]; then
        debug_log "Content is a movie, returning show ID: $1"
        printf "%s" "$1"
        return
    fi
    
    target_ep="$2"
    # Handle format like "1.5" -> Season 1, Episode 5
    if printf "%s" "$target_ep" | grep -q '\.'; then
        target_season=$(printf "%s" "$target_ep" | cut -d'.' -f1)
        target_episode=$(printf "%s" "$target_ep" | cut -d'.' -f2)
    else
        # If just a number, assume season 1
        target_season="1"
        target_episode="$target_ep"
    fi
    debug_log "Target: Season $target_season, Episode $target_episode"
    
    # Get season ID for target season - JioHotstar uses "s":"1" format (without S prefix)
    season_id=$(printf "%s" "$details" | grep -oE '"season":\[[^]]*\]' | sed 's/"season":\[//;s/\]//' | sed 's/},{/\n/g' | sed -nE 's/.*"s":"'"$target_season"'".*"id":"([^"]+)".*/\1/p; s/.*"id":"([^"]+)".*"s":"'"$target_season"'".*/\1/p' | head -1)
    debug_log "Season ID: $season_id"
    
    [ -z "$season_id" ] && return 1
    
    # Fetch episodes for that season
    timestamp=$(date +%s)
    ep_url="$jiohotstar_main/mobile/hs/episodes.php?s=$season_id&series=$1&t=$timestamp&page=1"
    debug_log "Episodes URL: $ep_url"
    ep_response=$(curl -s "$ep_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$jiohotstar_cookie; hd=on; ott=hs" \
        -H "Referer: $jiohotstar_main/home" \
        -A "$agent")
    debug_log "Episodes response (first 500 chars): $(printf '%.500s' "$ep_response")"
    
    # Find the episode ID matching our target episode number
    # JioHotstar API uses "ep":"E1" format (with E prefix), so we need to match "E" + episode number
    ep_id=$(printf "%s" "$ep_response" | sed 's/},{/\n/g' | sed -nE 's/.*"ep":"E'"$target_episode"'".*"id":"([^"]+)".*/\1/p; s/.*"id":"([^"]+)".*"ep":"E'"$target_episode"'".*/\1/p' | head -1)
    debug_log "Found episode ID: $ep_id"
    printf "%s" "$ep_id"
}

jiohotstar_get_episode_url() {
    jiohotstar_load_cookie
    debug_log "jiohotstar_get_episode_url: id=$id, ep_no=$ep_no"
    episode_id=$(jiohotstar_get_episode_id "$id" "$ep_no")
    [ -z "$episode_id" ] && die "Episode not found!"
    debug_log "Got episode ID: $episode_id"
    
    cache_dir="$(mktemp -d)"
    timestamp=$(date +%s)
    playlist_url="$jiohotstar_main/mobile/hs/playlist.php?id=$episode_id&t=$(printf '%s' "$allanime_title" | sed 's/ /%20/g')&tm=$timestamp"
    debug_log "Playlist URL: $playlist_url"
    
    response=$(curl -s "$playlist_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$jiohotstar_cookie; hd=on; ott=hs" \
        -H "Referer: $jiohotstar_main/home" \
        -A "$agent")
    
    # Store full response for audio/subtitle extraction
    jiohotstar_playlist_response="$response"
    
    debug_log "Playlist response (first 1000 chars): $(printf '%.1000s' "$response")"
    
    # Extract sources section (before tracks)
    sources_section=$(printf "%s" "$response" | sed 's/"tracks":.*//')
    
    # Normalize JSON - remove newlines and extra spaces
    normalized=$(printf "%s" "$sources_section" | tr -d '\n\r\t' | sed 's/  */ /g')
    
    # Extract m3u8 URLs - JioHotstar uses /mobile/hs/hls/ path
    links=""
    
    # Full HD (1080p) - has q=1080p parameter
    full_hd=$(printf "%s" "$normalized" | grep -oE '"file"[^}]*q=1080p[^"]*"[^}]*"label"[^}]*"Full HD"' | head -1)
    [ -z "$full_hd" ] && full_hd=$(printf "%s" "$normalized" | grep -oE '"label"[^}]*"Full HD"[^}]*"file"[^}]*m3u8[^"]*"' | head -1)
    if [ -n "$full_hd" ]; then
        url=$(printf "%s" "$full_hd" | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$url" ] && links="1080p >${jiohotstar_new}${url}"
    fi
    
    # Mid HD (720p) - has q=720p parameter
    mid_hd=$(printf "%s" "$normalized" | grep -oE '"file"[^}]*q=720p[^"]*"[^}]*"label"[^}]*"Mid HD"' | head -1)
    [ -z "$mid_hd" ] && mid_hd=$(printf "%s" "$normalized" | grep -oE '"label"[^}]*"Mid HD"[^}]*"file"[^}]*m3u8[^"]*"' | head -1)
    if [ -n "$mid_hd" ]; then
        url=$(printf "%s" "$mid_hd" | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$url" ] && links="${links}
720p >${jiohotstar_new}${url}"
    fi
    
    # Low HD (480p) - has q=480p parameter  
    low_hd=$(printf "%s" "$normalized" | grep -oE '"file"[^}]*q=480p[^"]*"[^}]*"label"[^}]*"Low HD"' | head -1)
    [ -z "$low_hd" ] && low_hd=$(printf "%s" "$normalized" | grep -oE '"label"[^}]*"Low HD"[^}]*"file"[^}]*m3u8[^"]*"' | head -1)
    if [ -n "$low_hd" ]; then
        url=$(printf "%s" "$low_hd" | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$url" ] && links="${links}
480p >${jiohotstar_new}${url}"
    fi
    
    # If no quality-specific links found, try to extract Auto/default
    if [ -z "$links" ]; then
        auto_url=$(printf "%s" "$normalized" | grep -oE '"file"[[:space:]]*:[[:space:]]*"[^"]*m3u8[^"]*"' | head -1 | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$auto_url" ] && links="auto >${jiohotstar_new}${auto_url}"
    fi
    
    # Remove leading newline if present
    links=$(printf "%s" "$links" | sed '/^$/d')
    
    debug_log "Extracted links:\n$links"
    
    # Extract English subtitle
    subtitle=$(printf "%s" "$response" | grep -oE '"kind":"captions"[^}]*"label":"English[^"]*"[^}]*"file":"[^"]*"' | head -1 | sed -nE 's/.*"file":"([^"]+)".*/\1/p' | sed 's|\\\/|/|g')
    [ -z "$subtitle" ] && subtitle=$(printf "%s" "$response" | grep -oE '"file":"[^"]*"[^}]*"label":"English[^"]*"[^}]*"kind":"captions"' | head -1 | sed -nE 's/.*"file":"([^"]+)".*/\1/p' | sed 's|\\\/|/|g')
    debug_log "Subtitle: $subtitle"
    
    if [ -n "$subtitle" ]; then
        case "$subtitle" in
            http*) ;;
            //*) subtitle="https:$subtitle" ;;
            /*) subtitle="https://subs.nfmirrorcdn.top$subtitle" ;;
        esac
        subtitle=$(printf "%s" "$subtitle" | sed 's|\(https://[^/]*\)//*|\1/|g; s|/\{2,\}|/|g')
        subs_flag="--sub-file=$subtitle"
    fi
    
    # Set referrer and cookie header for CDN requests
    refr_flag="--referrer=${jiohotstar_new}/ --http-header-fields=Cookie:\ hd=on"
    
    # Extract available subtitle languages
    jiohotstar_available_subs=$(printf "%s" "$response" | grep -oE '"kind":"captions"[^}]+' | sed -nE 's/.*"label":"([^"]+)".*/\1/p' | grep -v -iE '(\[CC\]|forced|\(1\))' | grep -vE '^[a-z]{2}$' | sort -u)
    
    select_quality "$quality"
    rm -r "$cache_dir" 2>/dev/null
    
    [ -z "$episode" ] && die "No valid sources found! Links: $links"
    
    # Store master m3u8 URL for audio track switching
    jiohotstar_master_url="$episode"
    
    # Extract available audio languages
    printf "\\33[2K\\r\\033[1;34mLoading audio tracks...\\033[0m\\n" >&2
    m3u8_content=$(curl -s "$jiohotstar_master_url" -H "Referer: ${jiohotstar_new}/" -H "Cookie: hd=on" -A "$agent" 2>/dev/null)
    jiohotstar_available_audio=$(printf "%s" "$m3u8_content" | grep -oE 'NAME="[^"]+"' | cut -d'"' -f2 | grep -v "^$" | sort -u)
    [ -z "$jiohotstar_available_audio" ] && jiohotstar_available_audio="English"
    
    # Set default audio track
    jiohotstar_selected_audio="${jiohotstar_selected_audio:-English}"
    jiohotstar_audio_file="--alang=${jiohotstar_selected_audio}"
    
    refr_flag="--referrer=${jiohotstar_new}/"
    
    debug_log "Available audio: $jiohotstar_available_audio"
    debug_log "Available subtitles: $jiohotstar_available_subs"
    debug_log "Video URL: $episode"
    debug_log "Selected audio: $jiohotstar_selected_audio"
}

# PRIMEVIDEO FUNCTIONS

primevideo_bypass() {
    cookie_file="$hist_dir/primevideo_cookie"
    # Check if cached cookie exists and is less than 15 hours old (54000 seconds)
    if [ -f "$cookie_file" ]; then
        cookie_age=$(($(date +%s) - $(stat -c %Y "$cookie_file" 2>/dev/null || stat -f %m "$cookie_file" 2>/dev/null || echo 0)))
        if [ "$cookie_age" -lt 54000 ]; then
            primevideo_cookie=$(cat "$cookie_file")
            debug_log "Using cached PrimeVideo cookie"
            [ -n "$primevideo_cookie" ] && return 0
        fi
    fi
    
    debug_log "Getting new PrimeVideo cookie from $primevideo_main/tv/p.php"
    printf "\33[2K\r\033[1;34mBypassing PrimeVideo (Mirror) protection...\033[0m\n" >&2
    max_attempts=10
    attempt=0
    while [ "$attempt" -lt "$max_attempts" ]; do
        response=$(curl -s -X POST "$primevideo_main/tv/p.php" -A "$agent" -D - 2>/dev/null)
        debug_log "Bypass attempt $((attempt + 1)): response status=$(printf '%s' \"$response\" | head -1)"
        if printf "%s" "$response" | grep -q '"r":"n"'; then
            primevideo_cookie=$(printf "%s" "$response" | grep -i 'set-cookie.*t_hash_t=' | sed -nE 's/.*t_hash_t=([^;]+);.*/\1/p' | head -1)
            debug_log "Extracted cookie: $primevideo_cookie"
            if [ -n "$primevideo_cookie" ]; then
                printf "%s" "$primevideo_cookie" > "$cookie_file"
                printf "\33[2K\r\033[1;32mPrimeVideo (Mirror) bypass successful!\033[0m\n" >&2
                return 0
            fi
        fi
        attempt=$((attempt + 1))
        sleep 1
    done
    die "Failed to bypass PrimeVideo (Mirror) protection after $max_attempts attempts"
}

primevideo_search() {
    primevideo_bypass
    timestamp=$(date +%s)
    printf "\33[2K\r\033[1;34mSearching PrimeVideo (Mirror)...\033[0m\n" >&2
    search_url="$primevideo_main/pv/search.php?s=$1&t=$timestamp"
    debug_log "Search URL: $search_url"
    search_result=$(curl -s "$search_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$primevideo_cookie; hd=on; ott=pv" \
        -H "Referer: $primevideo_main/home" \
        -A "$agent")
    debug_log "Search response: $search_result"
    # Parse JSON response - format: id<tab>title
    printf "%s" "$search_result" | sed 's/},{/\n/g' | sed -nE 's/.*"id":"([^"]+)".*"t":"([^"]+)".*/\1\t\2/p'
}

primevideo_load_cookie() {
    cookie_file="$hist_dir/primevideo_cookie"
    [ -f "$cookie_file" ] && primevideo_cookie=$(cat "$cookie_file")
}

primevideo_get_details() {
    primevideo_load_cookie
    timestamp=$(date +%s)
    details_url="$primevideo_main/pv/post.php?id=$1&t=$timestamp"
    debug_log "Getting details from: $details_url"
    result=$(curl -s "$details_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$primevideo_cookie; hd=on; ott=pv" \
        -H "Referer: $primevideo_main/tv/home" \
        -A "$agent")
    debug_log "Details response (first 500 chars): $(printf '%.500s' "$result")"
    printf "%s" "$result"
}

primevideo_episodes_list() {
    primevideo_load_cookie
    details=$(primevideo_get_details "$1")
    debug_log "primevideo_episodes_list: getting episodes for $1"
    # Check if it's a movie (no episodes)
    is_movie=$(printf "%s" "$details" | grep -o '"episodes":\[null\]')
    if [ -n "$is_movie" ]; then
        debug_log "Content is a movie, returning 1"
        printf "1\n"
        return
    fi
    
    # Extract all seasons info and generate episode list
    season_info=$(printf "%s" "$details" | grep -oE '"season":\[[^]]*\]' | sed 's/"season":\[//;s/\]//' | sed 's/},{/\n/g')
    debug_log "Season info: $season_info"
    printf "%s\n" "$season_info" | while IFS= read -r season_data; do
        [ -z "$season_data" ] && continue
        s_num=$(printf "%s" "$season_data" | sed -nE 's/.*"s":"([^"]+)".*/\1/p')
        ep_count=$(printf "%s" "$season_data" | sed -nE 's/.*"ep":"([^"]+)".*/\1/p')
        
        if [ -n "$s_num" ] && [ -n "$ep_count" ]; then
            i=1
            while [ "$i" -le "$ep_count" ]; do
                printf "%s.%s\n" "$s_num" "$i"
                i=$((i + 1))
            done
        fi
    done
}

primevideo_get_episode_id() {
    primevideo_load_cookie
    debug_log "primevideo_get_episode_id: id=$1, ep_no=$2"
    # For movies, return the show ID
    details=$(primevideo_get_details "$1")
    is_movie=$(printf "%s" "$details" | grep -o '"episodes":\[null\]')
    if [ -n "$is_movie" ]; then
        debug_log "Content is a movie, returning show ID: $1"
        printf "%s" "$1"
        return
    fi
    
    target_ep="$2"
    # Handle format like "1.5" -> Season 1, Episode 5
    if printf "%s" "$target_ep" | grep -q '\.'; then
        target_season=$(printf "%s" "$target_ep" | cut -d'.' -f1)
        target_episode=$(printf "%s" "$target_ep" | cut -d'.' -f2)
    else
        # If just a number, assume season 1
        target_season="1"
        target_episode="$target_ep"
    fi
    debug_log "Target: Season $target_season, Episode $target_episode"
    
    # Get season ID for target season
    season_id=$(printf "%s" "$details" | grep -oE '"season":\[[^]]*\]' | sed 's/"season":\[//;s/\]//' | sed 's/},{/\n/g' | sed -nE 's/.*"s":"'"$target_season"'".*"id":"([^"]+)".*/\1/p; s/.*"id":"([^"]+)".*"s":"'"$target_season"'".*/\1/p' | head -1)
    debug_log "Season ID: $season_id"
    
    [ -z "$season_id" ] && return 1
    
    # Fetch episodes for that season
    timestamp=$(date +%s)
    ep_url="$primevideo_main/pv/episodes.php?s=$season_id&series=$1&t=$timestamp&page=1"
    debug_log "Episodes URL: $ep_url"
    ep_response=$(curl -s "$ep_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$primevideo_cookie; hd=on; ott=pv" \
        -H "Referer: $primevideo_main/home" \
        -A "$agent")
    debug_log "Episodes response (first 500 chars): $(printf '%.500s' "$ep_response")"
    
    # Find the episode ID matching our target episode number (with E prefix like JioHotstar)
    ep_id=$(printf "%s" "$ep_response" | sed 's/},{/\n/g' | sed -nE 's/.*"ep":"E'"$target_episode"'".*"id":"([^"]+)".*/\1/p; s/.*"id":"([^"]+)".*"ep":"E'"$target_episode"'".*/\1/p' | head -1)
    debug_log "Found episode ID: $ep_id"
    printf "%s" "$ep_id"
}

primevideo_get_episode_url() {
    primevideo_load_cookie
    debug_log "primevideo_get_episode_url: id=$id, ep_no=$ep_no"
    episode_id=$(primevideo_get_episode_id "$id" "$ep_no")
    [ -z "$episode_id" ] && die "Episode not found!"
    debug_log "Got episode ID: $episode_id"
    
    cache_dir="$(mktemp -d)"
    timestamp=$(date +%s)
    # PrimeVideo uses /tv/pv/playlist.php path
    playlist_url="$primevideo_new/tv/pv/playlist.php?id=$episode_id&t=$(printf '%s' "$allanime_title" | sed 's/ /%20/g')&tm=$timestamp"
    debug_log "Playlist URL: $playlist_url"
    
    response=$(curl -s "$playlist_url" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Cookie: t_hash_t=$primevideo_cookie; hd=on; ott=pv" \
        -H "Referer: $primevideo_new/home" \
        -A "$agent")
    
    # Store full response for audio/subtitle extraction
    primevideo_playlist_response="$response"
    
    debug_log "Playlist response (first 1000 chars): $(printf '%.1000s' "$response")"
    
    # Extract sources section (before tracks)
    sources_section=$(printf "%s" "$response" | sed 's/"tracks":.*//')
    
    # Normalize JSON - remove newlines and extra spaces
    normalized=$(printf "%s" "$sources_section" | tr -d '\n\r\t' | sed 's/  */ /g')
    
    # Extract m3u8 URLs - PrimeVideo uses /tv/ path which needs to be replaced with /
    links=""
    
    # Full HD (1080p)
    full_hd=$(printf "%s" "$normalized" | grep -oE '"file"[^}]*q=1080p[^"]*"[^}]*"label"[^}]*"Full HD"' | head -1)
    [ -z "$full_hd" ] && full_hd=$(printf "%s" "$normalized" | grep -oE '"label"[^}]*"Full HD"[^}]*"file"[^}]*m3u8[^"]*"' | head -1)
    if [ -n "$full_hd" ]; then
        url=$(printf "%s" "$full_hd" | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        # Replace /tv/ with / in the path
        [ -n "$url" ] && url=$(printf "%s" "$url" | sed 's|/tv/|/|') && links="1080p >${primevideo_new}${url}"
    fi
    
    # Mid HD (720p)
    mid_hd=$(printf "%s" "$normalized" | grep -oE '"file"[^}]*q=720p[^"]*"[^}]*"label"[^}]*"Mid HD"' | head -1)
    [ -z "$mid_hd" ] && mid_hd=$(printf "%s" "$normalized" | grep -oE '"label"[^}]*"Mid HD"[^}]*"file"[^}]*m3u8[^"]*"' | head -1)
    if [ -n "$mid_hd" ]; then
        url=$(printf "%s" "$mid_hd" | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$url" ] && url=$(printf "%s" "$url" | sed 's|/tv/|/|') && links="${links}
720p >${primevideo_new}${url}"
    fi
    
    # Low HD (480p)
    low_hd=$(printf "%s" "$normalized" | grep -oE '"file"[^}]*q=480p[^"]*"[^}]*"label"[^}]*"Low HD"' | head -1)
    [ -z "$low_hd" ] && low_hd=$(printf "%s" "$normalized" | grep -oE '"label"[^}]*"Low HD"[^}]*"file"[^}]*m3u8[^"]*"' | head -1)
    if [ -n "$low_hd" ]; then
        url=$(printf "%s" "$low_hd" | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$url" ] && url=$(printf "%s" "$url" | sed 's|/tv/|/|') && links="${links}
480p >${primevideo_new}${url}"
    fi
    
    # If no quality-specific links found, try to extract Auto/default
    if [ -z "$links" ]; then
        auto_url=$(printf "%s" "$normalized" | grep -oE '"file"[[:space:]]*:[[:space:]]*"[^"]*m3u8[^"]*"' | head -1 | sed -nE 's/.*"file"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p')
        [ -n "$auto_url" ] && auto_url=$(printf "%s" "$auto_url" | sed 's|/tv/|/|') && links="auto >${primevideo_new}${auto_url}"
    fi
    
    # Remove leading newline if present
    links=$(printf "%s" "$links" | sed '/^$/d')
    
    debug_log "Extracted links:\n$links"
    
    # Extract English subtitle - PrimeVideo uses pv.subscdn.top
    subtitle=$(printf "%s" "$response" | grep -oE '"kind":"captions"[^}]*"label":"English[^"]*"[^}]*"file":"[^"]*"' | head -1 | sed -nE 's/.*"file":"([^"]+)".*/\1/p' | sed 's|\\\/|/|g')
    [ -z "$subtitle" ] && subtitle=$(printf "%s" "$response" | grep -oE '"file":"[^"]*"[^}]*"label":"English[^"]*"[^}]*"kind":"captions"' | head -1 | sed -nE 's/.*"file":"([^"]+)".*/\1/p' | sed 's|\\\/|/|g')
    debug_log "Subtitle: $subtitle"
    
    if [ -n "$subtitle" ]; then
        case "$subtitle" in
            http*) ;;
            //*) subtitle="https:$subtitle" ;;
            /*) subtitle="https://pv.subscdn.top$subtitle" ;;
        esac
        subtitle=$(printf "%s" "$subtitle" | sed 's|\(https://[^/]*\)//*|\1/|g; s|/\{2,\}|/|g')
        subs_flag="--sub-file=$subtitle"
    fi
    
    # Set referrer and cookie header for CDN requests
    refr_flag="--referrer=${primevideo_new}/ --http-header-fields=Cookie:\ hd=on;ott=pv"
    
    # Extract available subtitle languages
    primevideo_available_subs=$(printf "%s" "$response" | grep -oE '"kind":"captions"[^}]+' | sed -nE 's/.*"label":"([^"]+)".*/\1/p' | grep -v -iE '(\[CC\]|forced|\(1\))' | grep -vE '^[a-z]{2}$' | sort -u)
    
    select_quality "$quality"
    rm -r "$cache_dir" 2>/dev/null
    
    [ -z "$episode" ] && die "No valid sources found! Links: $links"
    
    # Store master m3u8 URL for audio track switching
    primevideo_master_url="$episode"
    
    # Extract available audio languages
    printf "\\33[2K\\r\\033[1;34mLoading audio tracks...\\033[0m\\n" >&2
    m3u8_content=$(curl -s "$primevideo_master_url" -H "Referer: ${primevideo_new}/" -H "Cookie: hd=on; ott=pv" -A "$agent" 2>/dev/null)
    primevideo_available_audio=$(printf "%s" "$m3u8_content" | grep -oE 'NAME="[^"]+"' | cut -d'"' -f2 | grep -v "^$" | sort -u)
    [ -z "$primevideo_available_audio" ] && primevideo_available_audio="English"
    
    # Set default audio track
    primevideo_selected_audio="${primevideo_selected_audio:-English}"
    primevideo_audio_file="--alang=${primevideo_selected_audio}"
    
    refr_flag="--referrer=${primevideo_new}/"
    
    debug_log "Available audio: $primevideo_available_audio"
    debug_log "Available subtitles: $primevideo_available_subs"
    debug_log "Video URL: $episode"
    debug_log "Selected audio: $primevideo_selected_audio"
}

# ================================
# HIANIME PROVIDER FUNCTIONS
# ================================

# Search HiAnime for anime
hianime_search() {
    query="$1"
    debug_log "hianime_search: query=$query"
    
    search_url="${hianime_base}/search?keyword=$(printf '%s' "$query" | sed 's/+/%20/g')"
    debug_log "Search URL: $search_url"
    
    # Fetch search page and extract anime cards
    response=$(curl -s "$search_url" \
        -H "User-Agent: $agent" \
        -H "Referer: ${hianime_base}/" \
        -H "Accept: text/html,application/xhtml+xml" 2>/dev/null)
    
    # Extract anime entries - look for film_list-wrap structure
    # Each item has: data-id, href, title (keep original order, use awk to remove duplicates while preserving order)
    printf "%s" "$response" | grep -oE '<a[^>]*href="/watch/[^"]*"[^>]*title="[^"]*"' | while read -r line; do
        href=$(printf "%s" "$line" | sed -nE 's/.*href="([^"]*)".*/\1/p')
        title=$(printf "%s" "$line" | sed -nE 's/.*title="([^"]*)".*/\1/p')
        # Extract anime ID from href (e.g., /watch/one-piece-100 -> one-piece-100)
        anime_id=$(printf "%s" "$href" | sed 's|^/watch/||; s|?.*||')
        [ -n "$anime_id" ] && [ -n "$title" ] && printf "%s\t%s\t%s\n" "$anime_id" "$title" "[HiAnime]"
    done | awk '!seen[$1]++'
}

# Get HiAnime anime details
hianime_get_details() {
    anime_id="$1"
    debug_log "hianime_get_details: anime_id=$anime_id"
    
    # Extract just the numeric ID from the end of anime slug
    anime_num=$(printf "%s" "$anime_id" | grep -oE '[0-9]+$')
    [ -z "$anime_num" ] && anime_num="$anime_id"
    debug_log "Anime numeric ID: $anime_num"
    
    watch_url="${hianime_base}/watch/${anime_id}"
    debug_log "Watch URL: $watch_url"
    
    response=$(curl -s "$watch_url" \
        -H "User-Agent: $agent" \
        -H "Referer: ${hianime_base}/" 2>/dev/null)
    
    # Extract title from page
    page_title=$(printf "%s" "$response" | grep -oE '<title>[^<]+</title>' | head -1 | sed 's/<[^>]*>//g; s/ - HiAnime.*//; s/Watch //; s/ English.*//; s/ Online.*//')
    [ -z "$page_title" ] && page_title="$anime_id"
    
    printf "%s" "$page_title"
}

# Get episode list for HiAnime anime
hianime_episodes_list() {
    anime_id="$1"
    debug_log "hianime_episodes_list: anime_id=$anime_id"
    
    # Extract numeric ID from the end of anime slug (e.g., one-piece-100 -> 100)
    anime_num=$(printf "%s" "$anime_id" | grep -oE '[0-9]+$')
    [ -z "$anime_num" ] && die "Could not extract anime ID from: $anime_id"
    debug_log "Anime numeric ID: $anime_num"
    
    # Fetch episode list via AJAX endpoint
    episodes_url="${hianime_ajax}/episode/list/${anime_num}"
    debug_log "Episodes URL: $episodes_url"
    
    response=$(curl -s "$episodes_url" \
        -H "User-Agent: $agent" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Referer: ${hianime_base}/watch/${anime_id}" 2>/dev/null)
    
    debug_log "Episodes response (first 500 chars): $(printf '%.500s' "$response")"
    
    # Parse episode list - use jq if available, otherwise fallback
    if command -v jq >/dev/null 2>&1; then
        html_content=$(printf "%s" "$response" | jq -r '.html' 2>/dev/null)
    else
        # Fallback: use python or sed to decode JSON
        if command -v python3 >/dev/null 2>&1; then
            html_content=$(printf "%s" "$response" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['html'])" 2>/dev/null)
        else
            # Last resort: basic sed decoding (may not work perfectly)
            html_content=$(printf "%s" "$response" | sed 's/.*"html":"//; s/",".*//; s/\\n/\n/g; s/\\"/"/g; s/\\\//\//g')
        fi
    fi
    
    # Extract episode numbers from data-number attributes
    printf "%s" "$html_content" | grep -oE 'data-number="[0-9]+"' | sed 's/data-number="//; s/"//' | sort -n
}

# Get episode server ID
hianime_get_episode_id() {
    anime_id="$1"
    target_episode="$2"
    debug_log "hianime_get_episode_id: anime_id=$anime_id, target_episode=$target_episode"
    
    # Extract numeric anime ID
    anime_num=$(printf "%s" "$anime_id" | grep -oE '[0-9]+$')
    [ -z "$anime_num" ] && return 1
    
    # Fetch episode list to get episode data-id
    episodes_url="${hianime_ajax}/episode/list/${anime_num}"
    response=$(curl -s "$episodes_url" \
        -H "User-Agent: $agent" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Referer: ${hianime_base}/watch/${anime_id}" 2>/dev/null)
    
    # Parse JSON to get HTML content
    if command -v jq >/dev/null 2>&1; then
        html_content=$(printf "%s" "$response" | jq -r '.html' 2>/dev/null)
    else
        if command -v python3 >/dev/null 2>&1; then
            html_content=$(printf "%s" "$response" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['html'])" 2>/dev/null)
        else
            html_content=$(printf "%s" "$response" | sed 's/.*"html":"//; s/",".*//; s/\\n/\n/g; s/\\"/"/g; s/\\\//\//g')
        fi
    fi
    
    # Find the episode with matching data-number and get its data-id from next line
    # Pattern: data-number="X" followed on next line by data-id="Y"
    episode_data_id=$(printf "%s" "$html_content" | grep -A1 "data-number=\"$target_episode\"" | grep -oE 'data-id="[0-9]+"' | head -1 | sed 's/data-id="//; s/"//')
    
    debug_log "Episode data-id: $episode_data_id"
    printf "%s" "$episode_data_id"
}

# Get streaming URL for HiAnime episode
hianime_get_episode_url() {
    debug_log "hianime_get_episode_url: id=$id, ep_no=$ep_no"
    
    cache_dir="$(mktemp -d)"
    
    # Get episode data-id
    episode_data_id=$(hianime_get_episode_id "$id" "$ep_no")
    [ -z "$episode_data_id" ] && die "Episode not found!"
    debug_log "Got episode data-id: $episode_data_id"
    
    # Get available servers for this episode
    servers_url="${hianime_ajax}/episode/servers?episodeId=${episode_data_id}"
    debug_log "Servers URL: $servers_url"
    
    servers_response=$(curl -s "$servers_url" \
        -H "User-Agent: $agent" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Referer: ${hianime_base}/watch/${id}" 2>/dev/null)
    
    debug_log "Servers response (first 500 chars): $(printf '%.500s' "$servers_response")"
    
    # Parse JSON to get HTML content
    if command -v jq >/dev/null 2>&1; then
        servers_html=$(printf "%s" "$servers_response" | jq -r '.html' 2>/dev/null)
    else
        if command -v python3 >/dev/null 2>&1; then
            servers_html=$(printf "%s" "$servers_response" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['html'])" 2>/dev/null)
        else
            servers_html=$(printf "%s" "$servers_response" | sed 's/.*"html":"//; s/",".*//; s/\\n/\n/g; s/\\"/"/g; s/\\\//\//g')
        fi
    fi
    
    debug_log "Servers HTML (first 500 chars): $(printf '%.500s' "$servers_html")"
    
    # Server mapping: data-server-id: 1=VidCloud/MegaCloud, 4=VidStreaming, 3=StreamTape, 6=Filemoon
    # Pattern spans multiple lines:
    # <div class="item server-item" data-type="sub" data-id="31995"
    #      data-server-id="1">
    # Use grep -A1 to capture both lines, then filter
    
    # Determine preferred type based on sub/dub preference
    preferred_type="$hianime_sub_or_dub"
    fallback_type="sub"
    [ "$preferred_type" = "sub" ] && fallback_type="dub"
    [ "$preferred_type" = "dub" ] && fallback_type="sub"
    debug_log "Preferred audio type: $preferred_type, fallback: $fallback_type"
    
    # First try VidCloud (server-id=1) with preferred type - best quality
    server_id=$(printf "%s" "$servers_html" | grep -A1 "server-item.*data-type=\"$preferred_type\"" | grep -B1 'data-server-id="1"' | head -1 | grep -oE 'data-id="[0-9]+"' | sed 's/data-id="//; s/"//')
    debug_log "VidCloud $preferred_type server: $server_id"
    
    # Try VidStreaming (server-id=4) with preferred type
    [ -z "$server_id" ] && server_id=$(printf "%s" "$servers_html" | grep -A1 "server-item.*data-type=\"$preferred_type\"" | grep -B1 'data-server-id="4"' | head -1 | grep -oE 'data-id="[0-9]+"' | sed 's/data-id="//; s/"//')
    debug_log "VidStreaming $preferred_type server: $server_id"
    
    # Try Filemoon (server-id=6) with preferred type
    [ -z "$server_id" ] && server_id=$(printf "%s" "$servers_html" | grep -A1 "server-item.*data-type=\"$preferred_type\"" | grep -B1 'data-server-id="6"' | head -1 | grep -oE 'data-id="[0-9]+"' | sed 's/data-id="//; s/"//')
    debug_log "Filemoon $preferred_type server: $server_id"
    
    # Try any server with preferred type (fallback)
    [ -z "$server_id" ] && server_id=$(printf "%s" "$servers_html" | grep "server-item.*data-type=\"$preferred_type\"" | head -1 | grep -oE 'data-id="[0-9]+"' | sed 's/data-id="//; s/"//')
    debug_log "Any $preferred_type server: $server_id"
    
    # Try VidCloud with fallback type
    [ -z "$server_id" ] && server_id=$(printf "%s" "$servers_html" | grep -A1 "server-item.*data-type=\"$fallback_type\"" | grep -B1 'data-server-id="1"' | head -1 | grep -oE 'data-id="[0-9]+"' | sed 's/data-id="//; s/"//')
    debug_log "VidCloud $fallback_type server: $server_id"
    
    # Try any server with fallback type
    [ -z "$server_id" ] && server_id=$(printf "%s" "$servers_html" | grep "server-item.*data-type=\"$fallback_type\"" | head -1 | grep -oE 'data-id="[0-9]+"' | sed 's/data-id="//; s/"//')
    debug_log "Any $fallback_type server: $server_id"
    
    [ -z "$server_id" ] && die "No streaming servers available!"
    debug_log "Selected server ID: $server_id"
    
    # Get the source/embed URL for this server
    sources_url="${hianime_ajax}/episode/sources?id=${server_id}"
    debug_log "Sources URL: $sources_url"
    
    sources_response=$(curl -s "$sources_url" \
        -H "User-Agent: $agent" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Referer: ${hianime_base}/watch/${id}" 2>/dev/null)
    
    debug_log "Sources response: $sources_response"
    
    # Extract embed link - format: {"type":"iframe","link":"https://megacloud.blog/embed-2/..."}
    embed_link=$(printf "%s" "$sources_response" | sed 's/\\//g' | grep -oE '"link":"[^"]+"' | head -1 | sed 's/"link":"//; s/"$//')
    
    [ -z "$embed_link" ] && die "Could not get embed link!"
    debug_log "Embed link: $embed_link"
    
    # Use MegaCloud API to extract actual video sources
    encoded_embed=$(printf "%s" "$embed_link" | sed 's|:|%3A|g; s|/|%2F|g; s|?|%3F|g; s|=|%3D|g; s|&|%26|g')
    megacloud_url="${megacloud_api}?url=${encoded_embed}"
    debug_log "MegaCloud API URL: $megacloud_url"
    
    megacloud_response=$(curl -s "$megacloud_url" \
        -H "User-Agent: $agent" \
        -H "Referer: ${hianime_base}/" 2>/dev/null)
    
    debug_log "MegaCloud response (first 1000 chars): $(printf '%.1000s' "$megacloud_response")"
    
    # Extract video sources from MegaCloud response using jq if available
    links=""
    
    if command -v jq >/dev/null 2>&1; then
        # Use jq to extract sources
        m3u8_url=$(printf "%s" "$megacloud_response" | jq -r '.sources[0].url // empty' 2>/dev/null)
        quality=$(printf "%s" "$megacloud_response" | jq -r '.sources[0].quality // "auto"' 2>/dev/null)
        [ -n "$m3u8_url" ] && links="${quality} >${m3u8_url}"
    else
        # Fallback: regex extraction
        m3u8_url=$(printf "%s" "$megacloud_response" | grep -oE '"url"[[:space:]]*:[[:space:]]*"[^"]+\.m3u8[^"]*"' | head -1 | sed 's/"url"[[:space:]]*:[[:space:]]*"//; s/"$//')
        [ -n "$m3u8_url" ] && links="auto >${m3u8_url}"
    fi
    
    debug_log "Extracted links: $links"
    
    [ -z "$links" ] && die "No video sources found!"
    
    # Extract subtitles from tracks
    if command -v jq >/dev/null 2>&1; then
        subtitle=$(printf "%s" "$megacloud_response" | jq -r '.tracks[] | select(.label | test("english"; "i")) | .url // .file' 2>/dev/null | head -1)
        [ -z "$subtitle" ] && subtitle=$(printf "%s" "$megacloud_response" | jq -r '.tracks[0].url // .tracks[0].file // empty' 2>/dev/null)
    else
        subtitle=$(printf "%s" "$megacloud_response" | grep -oE '"url"[[:space:]]*:[[:space:]]*"[^"]+\.vtt[^"]*"' | head -1 | sed 's/"url"[[:space:]]*:[[:space:]]*"//; s/"$//')
        [ -z "$subtitle" ] && subtitle=$(printf "%s" "$megacloud_response" | grep -oE '"file"[[:space:]]*:[[:space:]]*"[^"]+\.vtt[^"]*"' | head -1 | sed 's/"file"[[:space:]]*:[[:space:]]*"//; s/"$//')
    fi
    
    if [ -n "$subtitle" ]; then
        subs_flag="--sub-file=$subtitle"
        debug_log "Subtitle: $subtitle"
    fi
    
    # Set referrer for playback (use headers from API response if available)
    refr_flag="--referrer=${hianime_base}/"
    
    # Select quality
    printf "%s" "$links" > "$cache_dir/links"
    select_quality "$quality"
    
    rm -r "$cache_dir" 2>/dev/null
    
    [ -z "$episode" ] && die "No valid video sources found!"
    debug_log "Selected video URL: $episode"
}

# ================================
# ANIMEPAHE PROVIDER FUNCTIONS
# ================================

# AnimePahe cookie storage
animepahe_cookie=""

# Load AnimePahe cookie from file
animepahe_load_cookie() {
    cookie_file="$hist_dir/animepahe_cookie"
    if [ -f "$cookie_file" ]; then
        animepahe_cookie=$(cat "$cookie_file")
        debug_log "Loaded AnimePahe cookie from file"
    fi
}

# Save AnimePahe cookie to file
animepahe_save_cookie() {
    cookie_file="$hist_dir/animepahe_cookie"
    printf "%s" "$animepahe_cookie" > "$cookie_file"
    debug_log "Saved AnimePahe cookie to file"
}

# AnimePahe DDoS-Guard bypass
# This requires solving JS challenge - uses Playwright/Selenium for actual browser automation
animepahe_bypass() {
    cookie_file="$hist_dir/animepahe_cookie"
    
    # Check if cached cookie exists and is less than 6 hours old
    if [ -f "$cookie_file" ]; then
        cookie_age=$(($(date +%s) - $(stat -c %Y "$cookie_file" 2>/dev/null || stat -f %m "$cookie_file" 2>/dev/null || echo 0)))
        if [ "$cookie_age" -lt 21600 ]; then
            animepahe_cookie=$(cat "$cookie_file")
            debug_log "Using cached AnimePahe cookie (age: ${cookie_age}s)"
            [ -n "$animepahe_cookie" ] && return 0
        fi
    fi
    
    printf "\33[2K\r\033[1;34mBypassing AnimePahe DDoS-Guard protection...\033[0m\n" >&2
    
    # Method 1: Try Playwright (best - actual browser with JS execution)
    if command -v python3 >/dev/null 2>&1; then
        debug_log "Attempting Playwright browser bypass..."
        printf "\33[2K\r\033[1;33m Solving DDoS-Guard challenge (this may take 15-20 seconds)...\033[0m\n" >&2
        
        cookie_result=$(python3 << 'PYTHON_SCRIPT' 2>/dev/null
import sys
import time

# Try Playwright first (headless browser with full JS support)
try:
    from playwright.sync_api import sync_playwright
    
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        context = browser.new_context(
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            viewport={'width': 1920, 'height': 1080}
        )
        page = context.new_page()
        
        # Navigate to site
        page.goto('https://animepahe.si/', timeout=60000)
        
        # Wait for DDoS-Guard JS challenge to complete (needs 15+ seconds)
        time.sleep(15)
        
        # Navigate again after challenge cookies are set
        page.goto('https://animepahe.si/', timeout=30000)
        time.sleep(3)
        
        # Get cookies
        cookies = context.cookies()
        cookie_str = '; '.join([f"{c['name']}={c['value']}" for c in cookies])
        
        # Verify we're past the challenge
        content = page.content()
        
        browser.close()
        
        if cookie_str and 'DDoS-Guard' not in content:
            print(cookie_str)
            sys.exit(0)
            
except ImportError:
    pass
except Exception as e:
    pass

# Try Selenium as fallback
try:
    from selenium import webdriver
    from selenium.webdriver.chrome.options import Options
    import time
    
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    options.add_argument('--disable-gpu')
    options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36')
    
    driver = webdriver.Chrome(options=options)
    driver.get('https://animepahe.si/')
    
    # Wait for DDoS-Guard challenge to complete (needs 15+ seconds)
    time.sleep(15)
    
    # Navigate again to verify cookies work
    driver.get('https://animepahe.si/')
    time.sleep(3)
    
    # Get cookies
    cookies = driver.get_cookies()
    cookie_str = '; '.join([f"{c['name']}={c['value']}" for c in cookies])
    
    content = driver.page_source
    driver.quit()
    
    if cookie_str and 'DDoS-Guard' not in content:
        print(cookie_str)
        sys.exit(0)
        
except ImportError:
    pass
except Exception as e:
    pass

sys.exit(1)
PYTHON_SCRIPT
)
        
        if [ -n "$cookie_result" ]; then
            animepahe_cookie="$cookie_result"
            animepahe_save_cookie
            printf "\33[2K\r\033[1;32m AnimePahe bypass successful!\033[0m\n" >&2
            return 0
        fi
        
        debug_log "Browser bypass failed, trying cloudscraper..."
        
        # Method 2: Try cloudscraper (may work for some challenges)
        cookie_result=$(python3 << 'PYTHON_SCRIPT' 2>/dev/null
import sys
try:
    import cloudscraper
    scraper = cloudscraper.create_scraper(
        browser={'browser': 'chrome', 'platform': 'windows', 'mobile': False},
        delay=10
    )
    response = scraper.get('https://animepahe.si/')
    cookies = '; '.join([f'{c.name}={c.value}' for c in scraper.cookies])
    if cookies and response.status_code == 200 and 'DDoS-Guard' not in response.text:
        print(cookies)
        sys.exit(0)
except:
    pass
sys.exit(1)
PYTHON_SCRIPT
)
        
        if [ -n "$cookie_result" ]; then
            animepahe_cookie="$cookie_result"
            animepahe_save_cookie
            printf "\33[2K\r\033[1;32mAnimePahe bypass successful (cloudscraper)!\033[0m\n" >&2
            return 0
        fi
    fi
    
    # Method 3: Try with curl and cookie jar (may work if no JS challenge)
    debug_log "Trying curl with cookie jar..."
    tmp_cookie=$(mktemp)
    tmp_out=$(mktemp)
    
    # First request
    curl -s -c "$tmp_cookie" -b "$tmp_cookie" -L "${animepahe_base}/" \
        -H "User-Agent: $agent" \
        -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8" \
        -H "Accept-Language: en-US,en;q=0.5" \
        -H "Accept-Encoding: gzip, deflate" \
        -H "Connection: keep-alive" \
        -H "Upgrade-Insecure-Requests: 1" \
        --compressed \
        -o "$tmp_out" 2>/dev/null
    
    # Check if we got past the challenge
    if [ -f "$tmp_out" ] && ! grep -q "DDoS-Guard" "$tmp_out" 2>/dev/null; then
        # Read cookies from jar
        if [ -f "$tmp_cookie" ]; then
            ddg_cookies=$(awk 'NF && !/^#/ {printf "%s=%s; ", $6, $7}' "$tmp_cookie" 2>/dev/null | sed 's/; $//')
            if [ -n "$ddg_cookies" ]; then
                animepahe_cookie="$ddg_cookies"
                animepahe_save_cookie
                rm -f "$tmp_cookie" "$tmp_out"
                printf "\33[2K\r\033[1;32mAnimePahe bypass successful (curl)!\033[0m\n" >&2
                return 0
            fi
        fi
    fi
    
    rm -f "$tmp_cookie" "$tmp_out"
    
    # Method 3: Manual cookie input (fallback)
    printf "\33[2K\r\033[1;33m DDoS-Guard JS challenge detected.\033[0m\n" >&2
    printf "\033[1;36mAutomatic bypass failed. Please provide cookies manually:\033[0m\n" >&2
    printf "\n" >&2
    printf "  \033[1;37m1.\033[0m Open \033[1;34mhttps://animepahe.si\033[0m in your browser\n" >&2
    printf "  \033[1;37m2.\033[0m Wait for the page to load completely\n" >&2
    printf "  \033[1;37m3.\033[0m Open DevTools (F12)  Application  Cookies\n" >&2
    printf "  \033[1;37m4.\033[0m Copy all cookie values (format: name=value; name2=value2)\n" >&2
    printf "\n" >&2
    printf "  \033[1;90mTip: Install 'cloudscraper' for automatic bypass:\033[0m\n" >&2
    printf "  \033[1;90m     pip install cloudscraper\033[0m\n" >&2
    printf "\n" >&2
    printf "\033[1;33mPaste cookies (or Enter to skip): \033[0m" >&2
    read -r user_cookie
    
    if [ -n "$user_cookie" ]; then
        animepahe_cookie="$user_cookie"
        animepahe_save_cookie
        printf "\033[1;32mCookie saved!\033[0m\n" >&2
        return 0
    fi
    
    printf "\033[1;31mNo cookie provided. AnimePahe may not work.\033[0m\n" >&2
    return 1
}

# Search AnimePahe for anime
animepahe_search() {
    query="$1"
    debug_log "animepahe_search: query=$query"
    
    # Ensure we have a valid cookie
    animepahe_load_cookie
    if [ -z "$animepahe_cookie" ]; then
        animepahe_bypass || return 1
    fi
    
    search_url="${animepahe_base}/api?m=search&q=$(printf '%s' "$query" | sed 's/+/%20/g')"
    debug_log "Search URL: $search_url"
    debug_log "Using cookie: $animepahe_cookie"
    
    # Fetch search results from API with cookie
    response=$(curl -s "$search_url" \
        -H "User-Agent: $agent" \
        -H "Accept: application/json, text/javascript, */*; q=0.01" \
        -H "Accept-Language: en-US,en;q=0.9" \
        -H "Cookie: $animepahe_cookie" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Referer: ${animepahe_base}/" \
        -H "Sec-Fetch-Dest: empty" \
        -H "Sec-Fetch-Mode: cors" \
        -H "Sec-Fetch-Site: same-origin" 2>/dev/null)
    
    debug_log "Search response (first 500 chars): $(printf '%.500s' "$response")"
    
    # Check if we got a DDoS-Guard page instead of JSON
    if printf "%s" "$response" | grep -q "DDoS-Guard\|ddos-guard"; then
        debug_log "DDoS-Guard detected, clearing cookie and retrying..."
        rm -f "$hist_dir/animepahe_cookie"
        animepahe_cookie=""
        animepahe_bypass || return 1
        
        # Retry search
        response=$(curl -s "$search_url" \
            -H "User-Agent: $agent" \
            -H "Accept: application/json, text/javascript, */*; q=0.01" \
            -H "Cookie: $animepahe_cookie" \
            -H "X-Requested-With: XMLHttpRequest" \
            -H "Referer: ${animepahe_base}/" 2>/dev/null)
        
        debug_log "Retry response (first 500 chars): $(printf '%.500s' "$response")"
    fi
    
    # Parse JSON response - extract session (id), title, year, type
    # Format: {"total":N,"per_page":N,"data":[{"id":N,"title":"...","session":"...","poster":"...","year":N,"type":"...","score":N},...]}
    
    # Use jq if available for proper JSON parsing
    if command -v jq >/dev/null 2>&1; then
        printf "%s" "$response" | jq -r '.data[]? | "\(.session)\t\(.title) (\(.year), \(.type))\t[AnimePahe]"' 2>/dev/null
    else
        # Fallback: basic sed/grep parsing
        printf "%s" "$response" | tr '{' '\n' | grep -E '"session"' | while read -r item; do
            session=$(printf "%s" "$item" | sed -nE 's/.*"session":"([^"]+)".*/\1/p')
            title=$(printf "%s" "$item" | sed -nE 's/.*"title":"([^"]+)".*/\1/p')
            year=$(printf "%s" "$item" | sed -nE 's/.*"year":([0-9]+).*/\1/p')
            anime_type=$(printf "%s" "$item" | sed -nE 's/.*"type":"([^"]+)".*/\1/p')
            [ -n "$session" ] && [ -n "$title" ] && printf "%s\t%s (%s, %s)\t[AnimePahe]\n" "$session" "$title" "$year" "$anime_type"
        done
    fi
}

# Get AnimePahe anime details (title)
animepahe_get_details() {
    session_id="$1"
    debug_log "animepahe_get_details: session_id=$session_id"
    
    animepahe_load_cookie
    
    anime_url="${animepahe_base}/anime/${session_id}"
    debug_log "Anime URL: $anime_url"
    
    response=$(curl -s "$anime_url" \
        -H "User-Agent: $agent" \
        -H "Cookie: $animepahe_cookie" \
        -H "Referer: ${animepahe_base}/" 2>/dev/null)
    
    # Extract title from page
    page_title=$(printf "%s" "$response" | grep -oE '<h1[^>]*><span[^>]*>[^<]+</span>' | head -1 | sed 's/<[^>]*>//g')
    [ -z "$page_title" ] && page_title="$session_id"
    
    printf "%s" "$page_title"
}

# Get episode list for AnimePahe anime
animepahe_episodes_list() {
    session_id="$1"
    debug_log "animepahe_episodes_list: session_id=$session_id"
    
    animepahe_load_cookie
    
    # Store session ID for later use in episode URL fetching
    animepahe_session="$session_id"
    
    # Fetch first page to get total pages
    episodes_url="${animepahe_base}/api?m=release&id=${session_id}&sort=episode_asc&page=1"
    debug_log "Episodes URL: $episodes_url"
    
    response=$(curl -s "$episodes_url" \
        -H "User-Agent: $agent" \
        -H "Accept: application/json, text/javascript, */*; q=0.01" \
        -H "Cookie: $animepahe_cookie" \
        -H "X-Requested-With: XMLHttpRequest" \
        -H "Referer: ${animepahe_base}/anime/${session_id}" 2>/dev/null)
    
    debug_log "Episodes response (first 500 chars): $(printf '%.500s' "$response")"
    
    # Extract total pages and episode data
    if command -v jq >/dev/null 2>&1; then
        last_page=$(printf "%s" "$response" | jq -r '.last_page // 1' 2>/dev/null)
        # Store episode session mapping for later use
        printf "%s" "$response" | jq -r '.data[]? | "\(.episode)"' 2>/dev/null
        
        # Fetch remaining pages if any
        page=2
        while [ "$page" -le "$last_page" ]; do
            page_url="${animepahe_base}/api?m=release&id=${session_id}&sort=episode_asc&page=${page}"
            page_response=$(curl -s "$page_url" \
                -H "User-Agent: $agent" \
                -H "Accept: application/json, text/javascript, */*; q=0.01" \
                -H "Cookie: $animepahe_cookie" \
                -H "X-Requested-With: XMLHttpRequest" \
                -H "Referer: ${animepahe_base}/anime/${session_id}" 2>/dev/null)
            printf "%s" "$page_response" | jq -r '.data[]? | "\(.episode)"' 2>/dev/null
            page=$((page + 1))
        done
    else
        # Fallback: basic parsing
        last_page=$(printf "%s" "$response" | sed -nE 's/.*"last_page":([0-9]+).*/\1/p')
        [ -z "$last_page" ] && last_page=1
        
        printf "%s" "$response" | tr '{' '\n' | grep -E '"episode"' | sed -nE 's/.*"episode":([0-9.]+).*/\1/p'
        
        page=2
        while [ "$page" -le "$last_page" ]; do
            page_url="${animepahe_base}/api?m=release&id=${session_id}&sort=episode_asc&page=${page}"
            page_response=$(curl -s "$page_url" \
                -H "User-Agent: $agent" \
                -H "Accept: application/json, text/javascript, */*; q=0.01" \
                -H "Cookie: $animepahe_cookie" \
                -H "X-Requested-With: XMLHttpRequest" \
                -H "Referer: ${animepahe_base}/anime/${session_id}" 2>/dev/null)
            printf "%s" "$page_response" | tr '{' '\n' | grep -E '"episode"' | sed -nE 's/.*"episode":([0-9.]+).*/\1/p'
            page=$((page + 1))
        done
    fi
}

# Get episode session ID for AnimePahe
animepahe_get_episode_session() {
    session_id="$1"
    target_episode="$2"
    debug_log "animepahe_get_episode_session: session_id=$session_id, target_episode=$target_episode"
    
    animepahe_load_cookie
    
    # Fetch episodes and find the one matching target episode number
    page=1
    while true; do
        episodes_url="${animepahe_base}/api?m=release&id=${session_id}&sort=episode_asc&page=${page}"
        response=$(curl -s "$episodes_url" \
            -H "User-Agent: $agent" \
            -H "Accept: application/json, text/javascript, */*; q=0.01" \
            -H "Cookie: $animepahe_cookie" \
            -H "X-Requested-With: XMLHttpRequest" \
            -H "Referer: ${animepahe_base}/anime/${session_id}" 2>/dev/null)
        
        # Find episode session
        if command -v jq >/dev/null 2>&1; then
            ep_session=$(printf "%s" "$response" | jq -r ".data[]? | select(.episode == $target_episode or .episode == \"$target_episode\") | .session" 2>/dev/null | head -1)
            last_page=$(printf "%s" "$response" | jq -r '.last_page // 1' 2>/dev/null)
        else
            # Extract episode session using sed - look for matching episode number
            ep_session=$(printf "%s" "$response" | tr '{' '\n' | grep -E "\"episode\":$target_episode[,}]|\"episode\":\"$target_episode\"" | head -1 | sed -nE 's/.*"session":"([^"]+)".*/\1/p')
            last_page=$(printf "%s" "$response" | sed -nE 's/.*"last_page":([0-9]+).*/\1/p')
            [ -z "$last_page" ] && last_page=1
        fi
        
        [ -n "$ep_session" ] && break
        [ "$page" -ge "$last_page" ] && break
        page=$((page + 1))
    done
    
    debug_log "Found episode session: $ep_session"
    printf "%s" "$ep_session"
}

# Kwik URL extractor for AnimePahe
animepahe_extract_kwik() {
    kwik_url="$1"
    debug_log "animepahe_extract_kwik: url=$kwik_url"
    
    # Kwik uses Cloudflare protection - need Playwright to fetch page
    if command -v python3 >/dev/null 2>&1; then
        m3u8_url=$(python3 << PYTHON_SCRIPT 2>/dev/null
import sys
import re
import time

kwik_url = "$kwik_url"
referer = "${animepahe_base}/"

def unpack(p, a, c, k):
    """Unpack p.a.c.k.e.r encoded JavaScript"""
    k = k.split('|')
    def replacement(match):
        word = match.group(0)
        try:
            chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
            result = 0
            for char in word:
                result = result * a + chars.index(char)
            return k[result] if result < len(k) and k[result] else word
        except (ValueError, IndexError):
            return word
    return re.sub(r'\\b\\w+\\b', replacement, p)

# Try Playwright (can handle Cloudflare)
try:
    from playwright.sync_api import sync_playwright
    
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        context = browser.new_context(
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            viewport={'width': 1920, 'height': 1080}
        )
        page = context.new_page()
        page.set_extra_http_headers({'Referer': referer})
        page.goto(kwik_url, timeout=30000)
        time.sleep(3)
        
        content = page.content()
        browser.close()
        
        # Try direct m3u8 extraction first
        m3u8_match = re.search(r'https://[^"\'\\s\\\\]+\\.m3u8[^"\'\\s\\\\]*', content)
        if m3u8_match:
            url = m3u8_match.group(0).rstrip('\\\\')
            print(url)
            sys.exit(0)
        
        # Find all packed JS blocks and unpack them
        pattern = r"eval\\(function\\(p,a,c,k,e,d\\)\\{e=function.*?return p\\}\\('(.*?)',(\\d+),(\\d+),'([^']*)'"
        matches = re.findall(pattern, content, re.DOTALL)
        
        for p_val, a_val, c_val, k_val in matches:
            unpacked = unpack(p_val, int(a_val), int(c_val), k_val)
            # Look for m3u8 URL in unpacked content
            m3u8 = re.search(r'https://[^"\'\\s\\\\]+\\.m3u8', unpacked)
            if m3u8:
                url = m3u8.group(0).rstrip('\\\\')
                print(url)
                sys.exit(0)
                
except ImportError:
    pass
except Exception as e:
    pass

sys.exit(1)
PYTHON_SCRIPT
)
    fi
    
    debug_log "Extracted m3u8: $m3u8_url"
    printf "%s" "$m3u8_url"
}

# Get streaming URL for AnimePahe episode
animepahe_get_episode_url() {
    debug_log "animepahe_get_episode_url: id=$id, ep_no=$ep_no"
    
    animepahe_load_cookie
    
    cache_dir="$(mktemp -d)"
    
    # Get episode session
    ep_session=$(animepahe_get_episode_session "$id" "$ep_no")
    [ -z "$ep_session" ] && die "Episode not found!"
    debug_log "Got episode session: $ep_session"
    
    # Fetch play page to get available qualities/sources
    play_url="${animepahe_base}/play/${id}/${ep_session}"
    debug_log "Play URL: $play_url"
    
    play_response=$(curl -s "$play_url" \
        -H "User-Agent: $agent" \
        -H "Cookie: $animepahe_cookie" \
        -H "Referer: ${animepahe_base}/anime/${id}" 2>/dev/null)
    
    debug_log "Play response (first 1000 chars): $(printf '%.1000s' "$play_response")"
    
    # Extract quality options from resolution menu
    # Format: <button type="button" data-src="kwik_url" data-fansub="ABdex" data-resolution="720" data-audio="jpn" data-av1="0" class="dropdown-item">
    
    # Reset animepahe sources list
    animepahe_sources=""
    
    # Extract button opening tags with data-src attribute (handles buttons with nested spans)
    while read -r button; do
        kwik_url=$(printf "%s" "$button" | sed -nE 's/.*data-src="([^"]+)".*/\1/p')
        fansub=$(printf "%s" "$button" | sed -nE 's/.*data-fansub="([^"]+)".*/\1/p')
        resolution=$(printf "%s" "$button" | sed -nE 's/.*data-resolution="([^"]+)".*/\1/p')
        audio=$(printf "%s" "$button" | sed -nE 's/.*data-audio="([^"]+)".*/\1/p')
        
        if [ -n "$kwik_url" ] && [ -n "$resolution" ]; then
            # Create label from fansub and resolution
            label="${fansub}  ${resolution}p"
            [ "$audio" = "eng" ] && label="${label} (Dub)"
            # Store: resolution, kwik_url, audio, label (tab separated)
            animepahe_sources="${animepahe_sources}${resolution}\t${kwik_url}\t${audio}\t${label}\n"
        fi
    done << EOF
$(printf "%s" "$play_response" | grep -oE '<button[^>]*data-src="https://kwik[^"]*"[^>]*>')
EOF
    
    # Check if we have sources - try alternative method
    if [ -z "$animepahe_sources" ]; then
        # Alternative: just get any data-src with kwik URL
        while read -r kwik_url; do
            [ -n "$kwik_url" ] && animepahe_sources="${animepahe_sources}auto\t${kwik_url}\tjpn\tauto\n"
        done << EOF
$(printf "%s" "$play_response" | grep -oE 'data-src="(https://kwik[^"]*)"' | sed 's/data-src="//; s/"$//')
EOF
    fi
    
    if [ -z "$animepahe_sources" ]; then
        rm -r "$cache_dir" 2>/dev/null
        die "No video sources found!"
    fi
    
    # Store sources for quality change menu
    printf "%b" "$animepahe_sources" > "$cache_dir/sources"
    
    # Build links variable for change_quality menu (compatible with other providers)
    links=""
    while IFS=$'\t' read -r res url audio label; do
        [ -n "$label" ] && links="${links}${label}\n"
    done << EOF
$(printf "%b" "$animepahe_sources")
EOF
    
    # Use launcher for quality selection (consistent with other providers)
    source_count=$(printf "%b" "$animepahe_sources" | grep -c .)
    
    if [ "$source_count" -eq 1 ]; then
        # Only one source, use it directly
        source_line=$(printf "%b" "$animepahe_sources" | head -1)
        kwik_url=$(printf "%s" "$source_line" | cut -f2)
        source_quality=$(printf "%s" "$source_line" | cut -f4)
        animepahe_sub_or_dub=$(printf "%s" "$source_line" | cut -f3)
        [ "$animepahe_sub_or_dub" = "jpn" ] && animepahe_sub_or_dub="sub" || animepahe_sub_or_dub="dub"
    else
        # Multiple sources - use launcher for selection
        # Prepare launcher input: number url label
        idx=1
        launcher_input=""
        while IFS=$'\t' read -r res url audio label; do
            [ -n "$label" ] && launcher_input="${launcher_input}${idx}\t${url}\t${label}\n"
            idx=$((idx + 1))
        done << EOF
$(printf "%b" "$animepahe_sources")
EOF
        
        # Use nth function for selection (uses fzf/rofi based on settings)
        selected=$(printf "%b" "$launcher_input" | nth "Select quality: ")
        
        if [ -z "$selected" ]; then
            # Default to highest quality if no selection
            source_line=$(printf "%b" "$animepahe_sources" | sort -t$'\t' -k1 -rn | head -1)
            kwik_url=$(printf "%s" "$source_line" | cut -f2)
            source_quality=$(printf "%s" "$source_line" | cut -f4)
            animepahe_sub_or_dub=$(printf "%s" "$source_line" | cut -f3)
        else
            kwik_url=$(printf "%s" "$selected" | cut -f1)
            source_quality=$(printf "%s" "$selected" | cut -f2)
            # Find the audio type from sources
            animepahe_sub_or_dub=$(printf "%b" "$animepahe_sources" | grep "$kwik_url" | head -1 | cut -f3)
        fi
        [ "$animepahe_sub_or_dub" = "jpn" ] && animepahe_sub_or_dub="sub" || animepahe_sub_or_dub="dub"
    fi
    
    debug_log "Selected source: quality=$source_quality, url=$kwik_url, audio=$animepahe_sub_or_dub"
    
    if [ -z "$kwik_url" ]; then
        rm -r "$cache_dir" 2>/dev/null
        die "Could not extract video source!"
    fi
    
    # Extract m3u8 from kwik
    printf "\33[2K\r\033[1;34mExtracting video URL from Kwik (%s)...\033[0m\n" "$source_quality" >&2
    m3u8_url=$(animepahe_extract_kwik "$kwik_url")
    
    if [ -z "$m3u8_url" ]; then
        rm -r "$cache_dir" 2>/dev/null
        die "Could not extract m3u8 URL from Kwik!"
    fi
    
    # Set the video URL directly (no quality selection needed, already selected)
    episode="$m3u8_url"
    
    debug_log "Available m3u8: $m3u8_url"
    
    # Set referrer for Kwik playback
    refr_flag="--referrer=https://kwik.cx/"
    
    rm -r "$cache_dir" 2>/dev/null
    
    [ -z "$episode" ] && die "No valid video sources found!"
    debug_log "Selected video URL: $episode"
}

# GLOBAL SEARCH FUNCTION

global_search() {
    query="$1"
    printf "\033[1;36m\033[0m\n" >&2
    printf "\033[1;33m Global Search: %s\033[0m\n" "$(printf '%s' "$query" | sed 's/+/ /g')" >&2
    printf "\033[1;36m\033[0m\n" >&2
    
    combined_results=""
    
    # Search Netflix (limit to 5)
    printf "\n\033[1;35m[Netflix Mirror]\033[0m\n" >&2
    netflix_results=$(netflix_search "$query" 2>/dev/null | head -5)
    if [ -n "$netflix_results" ]; then
        count=1
        printf "%s\n" "$netflix_results" | while IFS= read -r line; do
            title=$(printf "%s" "$line" | cut -f2)
            printf "  %d. %s\n" "$count" "$title" >&2
            count=$((count + 1))
        done
        # Add provider prefix to results
        combined_results=$(printf "%s" "$netflix_results" | sed 's/^/netflix\t/')
    else
        printf "  \033[90mNo results found\033[0m\n" >&2
    fi
    
    # Search JioHotstar (limit to 5)
    printf "\n\033[1;35m[JioHotstar]\033[0m\n" >&2
    jiohotstar_results=$(jiohotstar_search "$query" 2>/dev/null | head -5)
    if [ -n "$jiohotstar_results" ]; then
        count=1
        printf "%s\n" "$jiohotstar_results" | while IFS= read -r line; do
            title=$(printf "%s" "$line" | cut -f2)
            printf "  %d. %s\n" "$count" "$title" >&2
            count=$((count + 1))
        done
        if [ -n "$combined_results" ]; then
            combined_results="$combined_results
$(printf "%s" "$jiohotstar_results" | sed 's/^/jiohotstar\t/')"
        else
            combined_results=$(printf "%s" "$jiohotstar_results" | sed 's/^/jiohotstar\t/')
        fi
    else
        printf "  \033[90mNo results found\033[0m\n" >&2
    fi
    
    # Search PrimeVideo (limit to 5)
    printf "\n\033[1;35m[PrimeVideo]\033[0m\n" >&2
    primevideo_results=$(primevideo_search "$query" 2>/dev/null | head -5)
    if [ -n "$primevideo_results" ]; then
        count=1
        printf "%s\n" "$primevideo_results" | while IFS= read -r line; do
            title=$(printf "%s" "$line" | cut -f2)
            printf "  %d. %s\n" "$count" "$title" >&2
            count=$((count + 1))
        done
        if [ -n "$combined_results" ]; then
            combined_results="$combined_results
$(printf "%s" "$primevideo_results" | sed 's/^/primevideo\t/')"
        else
            combined_results=$(printf "%s" "$primevideo_results" | sed 's/^/primevideo\t/')
        fi
    else
        printf "  \033[90mNo results found\033[0m\n" >&2
    fi
    
    # Search AllAnime (limit to 5)
    printf "\n\033[1;35m[AllAnime]\033[0m\n" >&2
    allanime_results=$(search_anime "$query" 2>/dev/null | head -5)
    if [ -n "$allanime_results" ]; then
        count=1
        printf "%s\n" "$allanime_results" | while IFS= read -r line; do
            title=$(printf "%s" "$line" | cut -f2)
            printf "  %d. %s\n" "$count" "$title" >&2
            count=$((count + 1))
        done
        if [ -n "$combined_results" ]; then
            combined_results="$combined_results
$(printf "%s" "$allanime_results" | sed 's/^/allanime\t/')"
        else
            combined_results=$(printf "%s" "$allanime_results" | sed 's/^/allanime\t/')
        fi
    else
        printf "  \033[90mNo results found\033[0m\n" >&2
    fi
    
    # Search HiAnime (limit to 5)
    printf "\n\033[1;35m[HiAnime]\033[0m\n" >&2
    hianime_results=$(hianime_search "$query" 2>/dev/null | head -5)
    if [ -n "$hianime_results" ]; then
        count=1
        printf "%s\n" "$hianime_results" | while IFS= read -r line; do
            title=$(printf "%s" "$line" | cut -f2)
            printf "  %d. %s\n" "$count" "$title" >&2
            count=$((count + 1))
        done
        if [ -n "$combined_results" ]; then
            combined_results="$combined_results
$(printf "%s" "$hianime_results" | sed 's/^/hianime\t/')"
        else
            combined_results=$(printf "%s" "$hianime_results" | sed 's/^/hianime\t/')
        fi
    else
        printf "  \033[90mNo results found\033[0m\n" >&2
    fi
    
    # Search AnimePahe (limit to 5)
    printf "\n\033[1;35m[AnimePahe]\033[0m\n" >&2
    animepahe_results=$(animepahe_search "$query" 2>/dev/null | head -5)
    if [ -n "$animepahe_results" ]; then
        count=1
        printf "%s\n" "$animepahe_results" | while IFS= read -r line; do
            title=$(printf "%s" "$line" | cut -f2)
            printf "  %d. %s\n" "$count" "$title" >&2
            count=$((count + 1))
        done
        if [ -n "$combined_results" ]; then
            combined_results="$combined_results
$(printf "%s" "$animepahe_results" | sed 's/^/animepahe\t/')"
        else
            combined_results=$(printf "%s" "$animepahe_results" | sed 's/^/animepahe\t/')
        fi
    else
        printf "  \033[90mNo results found\033[0m\n" >&2
    fi
    
    printf "\n\033[1;36m\033[0m\n" >&2
    
    # Return combined results for selection
    printf "%s" "$combined_results"
}

select_provider() {
    if [ -z "$provider" ]; then
        provider_list="1	global	Global Search (All Providers)
2	netflix	Netflix Mirror
3	jiohotstar	JioHotstar (Mirror)
4	primevideo	PrimeVideo (Mirror)
5	allanime	AllAnime (Anime)
6	hianime	HiAnime (Anime)
7	animepahe	AnimePahe (Anime)"
        provider_choice=$(printf "%s" "$provider_list" | nth "Select provider: ")
        [ -z "$provider_choice" ] && exit 1
        # Get the provider name (second field), not the number
        provider=$(printf "%s" "$provider_choice" | cut -f1)
        [ -z "$provider" ] && provider="allanime"
    fi
}

# checks if dependencies are present
dep_ch() {
    for dep; do
        command -v "${dep%% *}" >/dev/null || die "Program \"${dep%% *}\" not found. Please install it."
    done
}

where_iina() {
    [ -e "/Applications/IINA.app/Contents/MacOS/iina-cli" ] && echo "/Applications/IINA.app/Contents/MacOS/iina-cli" && return 0
    printf "%s" "iina" && return 0
}

where_mpv() {
    command -v "flatpak" >/dev/null && flatpak info io.mpv.Mpv >/dev/null 2>&1 && printf "%s" "flatpak_mpv" && return 0
    printf "%s" "mpv" && return 0
}

# SCRAPING

# extract the video links from response of embed urls, extract mp4 links form m3u8 lists
get_links() {
    response="$(curl -e "$allanime_refr" -s "https://${allanime_base}$*" -A "$agent")"
    episode_link="$(printf '%s' "$response" | sed 's|},{|\
|g' | sed -nE 's|.*link":"([^"]*)".*"resolutionStr":"([^"]*)".*|\2 >\1|p;s|.*hls","url":"([^"]*)".*"hardsub_lang":"en-US".*|\1|p')"

    case "$episode_link" in
        *repackager.wixmp.com*)
            extract_link=$(printf "%s" "$episode_link" | cut -d'>' -f2 | sed 's|repackager.wixmp.com/||g;s|\.urlset.*||g')
            for j in $(printf "%s" "$episode_link" | sed -nE 's|.*/,([^/]*),/mp4.*|\1|p' | sed 's|,|\
|g'); do
                printf "%s >%s\n" "$j" "$extract_link" | sed "s|,[^/]*|${j}|g"
            done | sort -nr
            ;;
        *master.m3u8*)
            m3u8_refr=$(printf '%s' "$response" | sed -nE 's|.*Referer":"([^"]*)".*|\1|p') && printf '%s\n' "m3u8_refr >$m3u8_refr" >"$cache_dir/m3u8_refr"
            extract_link=$(printf "%s" "$episode_link" | head -1 | cut -d'>' -f2)
            relative_link=$(printf "%s" "$extract_link" | sed 's|[^/]*$||')
            m3u8_streams="$(curl -e "$m3u8_refr" -s "$extract_link" -A "$agent")"
            printf "%s" "$m3u8_streams" | grep -q "EXTM3U" && printf "%s" "$m3u8_streams" | sed 's|^#EXT-X-STREAM.*x||g; s|,.*|p|g; /^#/d; $!N; s|\n| >|;/EXT-X-I-FRAME/d' |
                sed "s|>|cc>${relative_link}|g" | sort -nr
            printf '%s' "$response" | sed -nE 's|.*"subtitles":\[\{"lang":"en","label":"English","default":"default","src":"([^"]*)".*|subtitle >\1|p' >"$cache_dir/suburl"
            ;;
        *) [ -n "$episode_link" ] && printf "%s\n" "$episode_link" ;;
    esac

    printf "%s" "$*" | grep -q "tools.fast4speed.rsvp" && printf "%s\n" "Yt >$*"
    printf "\033[1;32m%s\033[0m Links Fetched\n" "$provider_name" 1>&2
}

# initialises provider_name and provider_id. First argument is the provider name, 2nd is the regex that matches that provider's link
provider_init() {
    provider_name=$1
    provider_id=$(printf "%s" "$resp" | sed -n "$2" | head -1 | cut -d':' -f2 | sed 's/../&\
/g' | sed 's/^79$/A/g;s/^7a$/B/g;s/^7b$/C/g;s/^7c$/D/g;s/^7d$/E/g;s/^7e$/F/g;s/^7f$/G/g;s/^70$/H/g;s/^71$/I/g;s/^72$/J/g;s/^73$/K/g;s/^74$/L/g;s/^75$/M/g;s/^76$/N/g;s/^77$/O/g;s/^68$/P/g;s/^69$/Q/g;s/^6a$/R/g;s/^6b$/S/g;s/^6c$/T/g;s/^6d$/U/g;s/^6e$/V/g;s/^6f$/W/g;s/^60$/X/g;s/^61$/Y/g;s/^62$/Z/g;s/^59$/a/g;s/^5a$/b/g;s/^5b$/c/g;s/^5c$/d/g;s/^5d$/e/g;s/^5e$/f/g;s/^5f$/g/g;s/^50$/h/g;s/^51$/i/g;s/^52$/j/g;s/^53$/k/g;s/^54$/l/g;s/^55$/m/g;s/^56$/n/g;s/^57$/o/g;s/^48$/p/g;s/^49$/q/g;s/^4a$/r/g;s/^4b$/s/g;s/^4c$/t/g;s/^4d$/u/g;s/^4e$/v/g;s/^4f$/w/g;s/^40$/x/g;s/^41$/y/g;s/^42$/z/g;s/^08$/0/g;s/^09$/1/g;s/^0a$/2/g;s/^0b$/3/g;s/^0c$/4/g;s/^0d$/5/g;s/^0e$/6/g;s/^0f$/7/g;s/^00$/8/g;s/^01$/9/g;s/^15$/-/g;s/^16$/./g;s/^67$/_/g;s/^46$/~/g;s/^02$/:/g;s/^17$/\//g;s/^07$/?/g;s/^1b$/#/g;s/^63$/\[/g;s/^65$/\]/g;s/^78$/@/g;s/^19$/!/g;s/^1c$/$/g;s/^1e$/&/g;s/^10$/\(/g;s/^11$/\)/g;s/^12$/*/g;s/^13$/+/g;s/^14$/,/g;s/^03$/;/g;s/^05$/=/g;s/^1d$/%/g' | tr -d '\n' | sed "s/\/clock/\/clock\.json/")
}

# generates links based on given provider
generate_link() {
    case $1 in
        1) provider_init "wixmp" "/Default :/p" ;;    # wixmp(default)(m3u8)(multi) -> (mp4)(multi)
        2) provider_init "youtube" "/Yt-mp4 :/p" ;;   # youtube(mp4)(single)
        3) provider_init "sharepoint" "/S-mp4 :/p" ;; # sharepoint(mp4)(single)
        *) provider_init "hianime" "/Luf-Mp4 :/p" ;;  # hianime(m3u8)(multi)
    esac
    [ -n "$provider_id" ] && get_links "$provider_id"
}

select_quality() {
    # removing urls which have soft subs to avoid playing on android, iSH and vlc (m3u8 streams don't get correct referrer)
    printf '%s' "$player_function" | cut -f1 -d" " | grep -qE '(android|iSH|vlc)' && links=$(printf '%s' "$links" | sed '/cc>/d;/subtitle >/d;/m3u8_refr >/d')
    printf '%s' "$player_function" | cut -f1 -d" " | grep -qE '(android|iSH)' && links=$(printf '%s' "$links" | sed '/Yt >/d')
    case "$1" in
        best) result=$(printf "%s" "$links" | head -n1) ;;
        worst) result=$(printf "%s" "$links" | grep -E '^[0-9]{3,4}' | tail -n1) ;;
        *) result=$(printf "%s" "$links" | grep -m 1 "$1") ;;
    esac
    [ -z "$result" ] && printf "Specified quality not found, defaulting to best\n" 1>&2 && result=$(printf "%s" "$links" | head -n1)

    # add refr,sub flags for m3u8 and refr flag for yt
    printf '%s' "$result" | grep -q "cc>" && subtitle="$(printf '%s' "$links" | sed -nE 's|subtitle >(.*)|\1|p')" &&
        [ -n "$subtitle" ] && subs_flag="--sub-file=$subtitle"
    printf '%s' "$result" | grep -q "cc>" && m3u8_refr="$(printf '%s' "$links" | sed -nE 's|m3u8_refr >(.*)|\1|p')" && refr_flag="--referrer=$m3u8_refr"
    printf "%s" "$result" | grep -q "tools.fast4speed.rsvp" && refr_flag="--referrer=$allanime_refr"

    ! (printf '%s' "$result" | grep -qE "(cc>|tools.fast4speed.rsvp)") && unset refr_flag
    ! (printf '%s' "$result" | grep -q "cc>") && unset subs_flag
    episode=$(printf "%s" "$result" | cut -d'>' -f2)
}

# gets embed urls, collects direct links into provider files, selects one with desired quality into $episode
get_episode_url() {
    # Use Netflix provider if selected
    if [ "$provider" = "netflix" ]; then
        netflix_get_episode_url
        return
    fi
    
    # Use JioHotstar provider if selected
    if [ "$provider" = "jiohotstar" ]; then
        jiohotstar_get_episode_url
        return
    fi
    
    # Use PrimeVideo provider if selected
    if [ "$provider" = "primevideo" ]; then
        primevideo_get_episode_url
        return
    fi
    
    # Use HiAnime provider if selected
    if [ "$provider" = "hianime" ]; then
        hianime_get_episode_url
        return
    fi
    
    # Use AnimePahe provider if selected
    if [ "$provider" = "animepahe" ]; then
        animepahe_get_episode_url
        return
    fi
    
    # get the embed urls of the selected episode
    #shellcheck disable=SC2016
    episode_embed_gql='query ($showId: String!, $translationType: VaildTranslationTypeEnumType!, $episodeString: String!) { episode( showId: $showId translationType: $translationType episodeString: $episodeString ) { episodeString sourceUrls }}'

    resp=$(curl -e "$allanime_refr" -s -G "${allanime_api}/api" --data-urlencode "variables={\"showId\":\"$id\",\"translationType\":\"$mode\",\"episodeString\":\"$ep_no\"}" --data-urlencode "query=$episode_embed_gql" -A "$agent" | tr '{}' '\n' | sed 's|\\u002F|\/|g;s|\\||g' | sed -nE 's|.*sourceUrl":"--([^"]*)".*sourceName":"([^"]*)".*|\2 :\1|p')
    # generate links into sequential files
    cache_dir="$(mktemp -d)"
    link_providers="1 2 3 4"
    for lp in $link_providers; do
        generate_link "$lp" >"$cache_dir"/"$lp" &
    done
    wait
    # select the link with matching quality
    links=$(cat "$cache_dir"/* | sort -g -r -s)
    rm -r "$cache_dir"
    select_quality "$quality"
    if printf "%s" "$ep_list" | grep -q "^$ep_no$"; then
        [ -z "$episode" ] && die "Episode is released, but no valid sources!"
    else
        [ -z "$episode" ] && die "Episode not released!"
    fi
}

# search the query and give results
search_anime() {
    #shellcheck disable=SC2016
    search_gql='query( $search: SearchInput $limit: Int $page: Int $translationType: VaildTranslationTypeEnumType $countryOrigin: VaildCountryOriginEnumType ) { shows( search: $search limit: $limit page: $page translationType: $translationType countryOrigin: $countryOrigin ) { edges { _id name availableEpisodes __typename } }}'

    curl -e "$allanime_refr" -s -G "${allanime_api}/api" --data-urlencode "variables={\"search\":{\"allowAdult\":false,\"allowUnknown\":false,\"query\":\"$1\"},\"limit\":40,\"page\":1,\"translationType\":\"$mode\",\"countryOrigin\":\"ALL\"}" --data-urlencode "query=$search_gql" -A "$agent" | sed 's|Show|\
| g' | sed -nE "s|.*_id\":\"([^\"]*)\",\"name\":\"(.+)\",.*${mode}\":([1-9][^,]*).*|\1	\2 (\3 episodes)|p" | sed 's/\\"//g'
}

time_until_next_ep() {
    animeschedule="https://animeschedule.net"
    query="$(printf "%s\n" "$*" | tr ' ' '+')"
    curl -s -G "$animeschedule/api/v3/anime" --data "q=${query}" | sed 's|"id"|\n|g' | sed -nE 's|.*,"route":"([^"]*)","premier.*|\1|p' | while read -r anime; do
        data=$(curl -s "$animeschedule/anime/$anime" | sed '1,/"anime-header-list-buttons-wrapper"/d' | sed -nE 's|.*countdown-time-raw" datetime="([^"]*)">.*|Next Raw Release: \1|p;s|.*countdown-time" datetime="([^"]*)">.*|Next Sub Release: \1|p;s|.*english-title">([^<]*)<.*|English Title: \1|p;s|.*main-title".*>([^<]*)<.*|Japanese Title: \1|p')
        status="Ongoing"
        color="33"
        printf "%s\n" "$data"
        ! (printf "%s\n" "$data" | grep -q "Next Raw Release:") && status="Finished" && color="32"
        printf "Status:  \033[1;%sm%s\033[0m\n---\n" "$color" "$status"
    done
    exit 0
}

# get the episodes list of the selected anime
episodes_list() {
    #shellcheck disable=SC2016
    episodes_list_gql='query ($showId: String!) { show( _id: $showId ) { _id availableEpisodesDetail }}'

    curl -e "$allanime_refr" -s -G "${allanime_api}/api" --data-urlencode "variables={\"showId\":\"$*\"}" --data-urlencode "query=$episodes_list_gql" -A "$agent" | sed -nE "s|.*$mode\":\[([0-9.\",]*)\].*|\1|p" | sed 's|,|\
|g; s|"||g' | sort -n -k 1
}

# PLAYING

process_hist_entry() {
    ep_list=$(episodes_list "$id")
    latest_ep=$(printf "%s\n" "$ep_list" | tail -n1)
    title=$(printf "%s\n" "$title" | sed "s|[0-9]\+ episodes|${latest_ep} episodes|")
    ep_no=$(printf "%s" "$ep_list" | sed -n "/^${ep_no}$/{n;p;}") 2>/dev/null
    [ -n "$ep_no" ] && printf "%s\t%s - episode %s\n" "$id" "$title" "$ep_no"
}

update_history() {
    if grep -q -- "$id" "$histfile"; then
        sed -E "s|^[^	]+	${id}	[^	]+$|${ep_no}	${id}	${title}|" "$histfile" >"${histfile}.new"
    else
        cp "$histfile" "${histfile}.new"
        printf "%s\t%s\t%s\n" "$ep_no" "$id" "$title" >>"${histfile}.new"
    fi
    mv "${histfile}.new" "$histfile"
}

download() {
    # download subtitle if it's set
    [ -n "$subtitle" ] && curl -s "$subtitle" -o "$download_dir/$2.vtt"
    case $1 in
        *m3u8*)
            if command -v "yt-dlp" >/dev/null; then
                if [ "$provider" = "netflix" ]; then
                    # Netflix needs special headers
                    yt-dlp --referer "${netflix_new}/" --add-header "Cookie:hd=on" "$1" --no-skip-unavailable-fragments --fragment-retries infinite -N 16 -o "$download_dir/$2.mp4"
                elif [ "$provider" = "jiohotstar" ]; then
                    # JioHotstar needs special headers
                    yt-dlp --referer "${jiohotstar_new}/" --add-header "Cookie:hd=on" "$1" --no-skip-unavailable-fragments --fragment-retries infinite -N 16 -o "$download_dir/$2.mp4"
                elif [ "$provider" = "primevideo" ]; then
                    # PrimeVideo needs special headers
                    yt-dlp --referer "${primevideo_new}/" --add-header "Cookie:hd=on;ott=pv" "$1" --no-skip-unavailable-fragments --fragment-retries infinite -N 16 -o "$download_dir/$2.mp4"
                elif [ "$provider" = "animepahe" ]; then
                    # AnimePahe needs Kwik referrer
                    yt-dlp --referer "https://kwik.cx/" "$1" --no-skip-unavailable-fragments --fragment-retries infinite -N 16 -o "$download_dir/$2.mp4"
                else
                    yt-dlp --referer "$m3u8_refr" "$1" --no-skip-unavailable-fragments --fragment-retries infinite -N 16 -o "$download_dir/$2.mp4"
                fi
            else
                if [ "$provider" = "netflix" ]; then
                    ffmpeg -headers "Cookie: hd=on" -referer "${netflix_new}/" -loglevel error -stats -i "$1" -c copy "$download_dir/$2.mp4"
                elif [ "$provider" = "jiohotstar" ]; then
                    ffmpeg -headers "Cookie: hd=on" -referer "${jiohotstar_new}/" -loglevel error -stats -i "$1" -c copy "$download_dir/$2.mp4"
                elif [ "$provider" = "primevideo" ]; then
                    ffmpeg -headers "Cookie: hd=on; ott=pv" -referer "${primevideo_new}/" -loglevel error -stats -i "$1" -c copy "$download_dir/$2.mp4"
                elif [ "$provider" = "animepahe" ]; then
                    ffmpeg -referer "https://kwik.cx/" -loglevel error -stats -i "$1" -c copy "$download_dir/$2.mp4"
                else
                    ffmpeg -extension_picky 0 -referer "$m3u8_refr" -loglevel error -stats -i "$1" -c copy "$download_dir/$2.mp4"
                fi
            fi
            # embed subs into downloads
            # [ -e "$download_dir/$2.vtt" ] && ffmpeg -i "$download_dir/$2.mp4" -i "$download_dir/$2.vtt" -c copy -c:s mov_text "$download_dir/$2.bak.mp4" && mv "$download_dir/$2.bak.mp4" "$download_dir/$2.mp4"
            ;;
        *)
            # shellcheck disable=SC2086
            aria2c --referer="$allanime_refr" --enable-rpc=false --check-certificate=false --continue $iSH_DownFix --summary-interval=0 -x 16 -s 16 "$1" --dir="$download_dir" -o "$2.mp4" --download-result=hide
            ;;
    esac
}

play_episode() {
    debug_log "play_episode: title=$allanime_title, ep_no=$ep_no, provider=$provider"
    [ "$log_episode" = 1 ] && [ "$player_function" != "debug" ] && [ "$player_function" != "download" ] && command -v logger >/dev/null && logger -t ani-cli "${allanime_title}${ep_no}"
    [ "$skip_intro" = 1 ] && skip_flag="$(ani-skip -q "$mal_id" -e "$ep_no")"
    
    # Kill previous player instance before starting new one
    case "$player_function" in
        vlc*) pkill -9 vlc 2>/dev/null ;;
        mpv*) pkill -9 mpv 2>/dev/null ;;
        flatpak_mpv) pkill -9 -f "io.mpv.Mpv" 2>/dev/null ;;
        *iina*) pkill -9 -f "IINA" 2>/dev/null ;;
    esac
    sleep 0.3
    
    # Show loading message
    [ "$player_function" != "debug" ] && [ "$player_function" != "download" ] && printf "\33[2K\r\033[1;33mLoading video...\033[0m\n" >&2
    
    [ -z "$episode" ] && get_episode_url
    debug_log "Episode URL: $episode"
    debug_log "Subtitle flag: $subs_flag"
    debug_log "Referrer flag: $refr_flag"
    
    # Show opening player message
    [ "$player_function" != "debug" ] && [ "$player_function" != "download" ] && printf "\\33[2K\\r\\033[1;32mOpening player...\\033[0m\\n" >&2
    
    # shellcheck disable=SC2086
    case "$player_function" in
        debug)
            printf "All links:\\n%s\\nSelected link:\\n" "$links"
            printf "%s\\n" "$episode"
            printf "Audio file: %s\\n" "$netflix_audio_file"
            printf "Subtitle flag: %s\\n" "$subs_flag"
            ;;
        mpv*)
            # Build subtitle option
            mpv_subs=""
            [ -n "$subs_flag" ] && mpv_subs="$subs_flag"
            
            # Get audio file flag based on provider
            audio_flag=""
            [ "$provider" = "netflix" ] && [ -n "$netflix_audio_file" ] && audio_flag="$netflix_audio_file"
            [ "$provider" = "jiohotstar" ] && [ -n "$jiohotstar_audio_file" ] && audio_flag="$jiohotstar_audio_file"
            [ "$provider" = "primevideo" ] && [ -n "$primevideo_audio_file" ] && audio_flag="$primevideo_audio_file"
            
            if [ "$no_detach" = 0 ]; then
                if [ -n "$audio_flag" ]; then
                    nohup $player_function --force-window=yes $skip_flag --force-media-title="${allanime_title}Episode ${ep_no}" "$episode" $mpv_subs $refr_flag $audio_flag >/dev/null 2>&1 &
                else
                    nohup $player_function --force-window=yes $skip_flag --force-media-title="${allanime_title}Episode ${ep_no}" "$episode" $mpv_subs $refr_flag >/dev/null 2>&1 &
                fi
            else
                if [ -n "$audio_flag" ]; then
                    $player_function --force-window=yes $skip_flag $mpv_subs $refr_flag $audio_flag --force-media-title="${allanime_title}Episode ${ep_no}" "$episode"
                else
                    $player_function --force-window=yes $skip_flag $mpv_subs $refr_flag --force-media-title="${allanime_title}Episode ${ep_no}" "$episode"
                fi
                mpv_exitcode=$?
                [ "$exit_after_play" = 1 ] && [ -z "$range" ] && exit "$mpv_exitcode"
            fi
            ;;
        android_mpv) nohup am start --user 0 -a android.intent.action.VIEW -d "$episode" -n is.xyz.mpv/.MPVActivity >/dev/null 2>&1 & ;;
        android_vlc) nohup am start --user 0 -a android.intent.action.VIEW -d "$episode" -n org.videolan.vlc/org.videolan.vlc.gui.video.VideoPlayerActivity -e "title" "${allanime_title}Episode ${ep_no}" >/dev/null 2>&1 & ;;
        *iina*)
            [ -n "$subs_flag" ] && subs_flag="--mpv-${subs_flag#--}"
            [ -n "$refr_flag" ] && refr_flag="--mpv-${refr_flag#--}"
            if pgrep -f "IINA" >/dev/null 2>&1; then
                # omit --keep-running when an IINA instance exists to prevent hanging
                nohup $player_function --no-stdin --mpv-force-media-title="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag "$episode" >/dev/null 2>&1 &
            else
                nohup $player_function --no-stdin --keep-running --mpv-force-media-title="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag "$episode" >/dev/null 2>&1 &
            fi
            ;;
        flatpak_mpv)
            audio_flag=""
            [ "$provider" = "netflix" ] && [ -n "$netflix_audio_file" ] && audio_flag="$netflix_audio_file"
            [ "$provider" = "jiohotstar" ] && [ -n "$jiohotstar_audio_file" ] && audio_flag="$jiohotstar_audio_file"
            [ "$provider" = "primevideo" ] && [ -n "$primevideo_audio_file" ] && audio_flag="$primevideo_audio_file"
            if [ -n "$audio_flag" ]; then
                flatpak run io.mpv.Mpv --force-window=yes --force-media-title="${allanime_title}Episode ${ep_no}" "$episode" $mpv_subs $refr_flag $audio_flag >/dev/null 2>&1 &
            else
                flatpak run io.mpv.Mpv --force-window=yes --force-media-title="${allanime_title}Episode ${ep_no}" "$episode" $mpv_subs $refr_flag >/dev/null 2>&1 &
            fi
            ;;
        vlc*) 
            # For VLC, download subtitle to temp file and use --sub-file
            vlc_sub_opt=""
            if [ -n "$subtitle" ]; then
                sub_tmp="$(mktemp --suffix=.srt)"
                curl -s "$subtitle" -o "$sub_tmp" 2>/dev/null
                [ -s "$sub_tmp" ] && vlc_sub_opt="--sub-file=$sub_tmp"
            fi
            # VLC audio track selection - find track index from available audio list
            vlc_audio_opt=""
            if [ "$provider" = "netflix" ] && [ -n "$netflix_selected_audio" ] && [ -n "$netflix_available_audio" ]; then
                audio_index=$(printf "%s" "$netflix_available_audio" | grep -n "^${netflix_selected_audio}$" | cut -d: -f1)
                [ -n "$audio_index" ] && vlc_audio_opt="--audio-track=$audio_index"
            elif [ "$provider" = "jiohotstar" ] && [ -n "$jiohotstar_selected_audio" ] && [ -n "$jiohotstar_available_audio" ]; then
                audio_index=$(printf "%s" "$jiohotstar_available_audio" | grep -n "^${jiohotstar_selected_audio}$" | cut -d: -f1)
                [ -n "$audio_index" ] && vlc_audio_opt="--audio-track=$audio_index"
            elif [ "$provider" = "primevideo" ] && [ -n "$primevideo_selected_audio" ] && [ -n "$primevideo_available_audio" ]; then
                audio_index=$(printf "%s" "$primevideo_available_audio" | grep -n "^${primevideo_selected_audio}$" | cut -d: -f1)
                [ -n "$audio_index" ] && vlc_audio_opt="--audio-track=$audio_index"
            fi
            if [ "$provider" = "netflix" ]; then
                nohup $player_function --http-referrer="${netflix_new}/" --play-and-exit --meta-title="${allanime_title}Episode ${ep_no}" ":http-user-agent=Mozilla/5.0" ":http-cookies=hd=on" $vlc_audio_opt $vlc_sub_opt "$episode" >/dev/null 2>&1 &
            elif [ "$provider" = "jiohotstar" ]; then
                nohup $player_function --http-referrer="${jiohotstar_new}/" --play-and-exit --meta-title="${allanime_title}Episode ${ep_no}" ":http-user-agent=Mozilla/5.0" ":http-cookies=hd=on" $vlc_audio_opt $vlc_sub_opt "$episode" >/dev/null 2>&1 &
            elif [ "$provider" = "primevideo" ]; then
                nohup $player_function --http-referrer="${primevideo_new}/" --play-and-exit --meta-title="${allanime_title}Episode ${ep_no}" ":http-user-agent=Mozilla/5.0" ":http-cookies=hd=on;ott=pv" $vlc_audio_opt $vlc_sub_opt "$episode" >/dev/null 2>&1 &
            elif [ "$provider" = "hianime" ]; then
                nohup $player_function --http-referrer="${hianime_base}/" --play-and-exit --meta-title="${allanime_title}Episode ${ep_no}" ":http-user-agent=Mozilla/5.0" $vlc_sub_opt "$episode" >/dev/null 2>&1 &
            elif [ "$provider" = "animepahe" ]; then
                nohup $player_function --http-referrer="https://kwik.cx/" --play-and-exit --meta-title="${allanime_title}Episode ${ep_no}" ":http-user-agent=Mozilla/5.0" $vlc_sub_opt "$episode" >/dev/null 2>&1 &
            else
                nohup $player_function --http-referrer="${allanime_refr}" --play-and-exit --meta-title="${allanime_title}Episode ${ep_no}" $vlc_sub_opt "$episode" >/dev/null 2>&1 &
            fi
            ;;
        *yncpla*) nohup $player_function "$episode" -- --force-media-title="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag >/dev/null 2>&1 & ;;
        download) "$player_function" "$episode" "${allanime_title}Episode ${ep_no}" "$subtitle" ;;
        catt) nohup catt cast "$episode" -s "$subtitle" >/dev/null 2>&1 & ;;
        iSH)
            printf "\e]8;;vlc://%s\a~~~~~~~~~~~~~~~~~~~~\n~ Tap to open VLC ~\n~~~~~~~~~~~~~~~~~~~~\e]8;;\a\n" "$episode"
            sleep 5
            ;;
        *) nohup $player_function "$episode" >/dev/null 2>&1 & ;;
    esac
    replay="$episode"
    unset episode
    update_history
    [ "$use_external_menu" = "1" ] && wait
}

play() {
    start=$(printf "%s" "$ep_no" | grep -Eo '^(-1|[0-9]+(\.[0-9]+)?)')
    end=$(printf "%s" "$ep_no" | grep -Eo '(-1|[0-9]+(\.[0-9]+)?)$')
    [ "$start" = "-1" ] && ep_no=$(printf "%s" "$ep_list" | tail -n1) && unset start
    [ -z "$end" ] || [ "$end" = "$start" ] && unset start end
    [ "$end" = "-1" ] && end=$(printf "%s" "$ep_list" | tail -n1)
    line_count=$(printf "%s\n" "$ep_no" | wc -l | tr -d "[:space:]")
    if [ "$line_count" != 1 ] || [ -n "$start" ]; then
        [ -z "$start" ] && start=$(printf "%s\n" "$ep_no" | head -n1)
        [ -z "$end" ] && end=$(printf "%s\n" "$ep_no" | tail -n1)
        range=$(printf "%s\n" "$ep_list" | sed -nE "/^${start}\$/,/^${end}\$/p")
        [ -z "$range" ] && die "Invalid range!"
        for i in $range; do
            tput clear
            ep_no=$i
            printf "\33[2K\r\033[1;34mPlaying episode %s...\033[0m\n" "$ep_no"
            [ "$i" = "$end" ] && unset range
            play_episode
        done
    else
        play_episode
    fi
    # moves up to stored position and deletes to end
    [ "$player_function" != "debug" ] && [ "$player_function" != "download" ] && tput rc && tput ed
}

# MAIN

# setup
agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0"
allanime_refr="https://allmanga.to"
allanime_base="allanime.day"
allanime_api="https://api.${allanime_base}"
mode="${ANI_CLI_MODE:-sub}"
download_dir="${ANI_CLI_DOWNLOAD_DIR:-.}"
log_episode="${ANI_CLI_LOG:-1}"
quality="${ANI_CLI_QUALITY:-best}"
case "$(uname -a | cut -d " " -f 1,3-)" in
    *Darwin*) player_function="${ANI_CLI_PLAYER:-$(where_iina)}" ;;   # mac OS
    *ndroid*) player_function="${ANI_CLI_PLAYER:-android_mpv}" ;;     # Android OS (termux)
    *MINGW* | *WSL2*) player_function="${ANI_CLI_PLAYER:-mpv.exe}" ;; # Windows OS
    *ish*) player_function="${ANI_CLI_PLAYER:-iSH}" ;;                # iOS (iSH)
    *) player_function="${ANI_CLI_PLAYER:-$(where_mpv)}" ;;           # Linux OS
esac

no_detach="${ANI_CLI_NO_DETACH:-0}"
exit_after_play="${ANI_CLI_EXIT_AFTER_PLAY:-0}"
use_external_menu="${ANI_CLI_EXTERNAL_MENU:-0}"
external_menu_normal_window="${ANI_CLI_EXTERNAL_MENU_NORMAL_WINDOW:-0}"
skip_intro="${ANI_CLI_SKIP_INTRO:-0}"
debug_mode="${ANI_CLI_DEBUG:-0}"
# shellcheck disable=SC2154
skip_title="$ANI_CLI_SKIP_TITLE"
[ -t 0 ] || use_external_menu=1
hist_dir="${ANI_CLI_HIST_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/ani-cli}"
[ ! -d "$hist_dir" ] && mkdir -p "$hist_dir"
histfile="$hist_dir/ani-hsts"
[ ! -f "$histfile" ] && : >"$histfile"
search="${ANI_CLI_DEFAULT_SOURCE:-scrape}"

while [ $# -gt 0 ]; do
    case "$1" in
        -v | --vlc)
            case "$(uname -a | cut -d " " -f 1,3-)" in
                *ndroid*) player_function="android_vlc" ;;
                MINGW* | *WSL2*) player_function="vlc.exe" ;;
                *ish*) player_function="iSH" ;;
                *) player_function="vlc" ;;
            esac
            ;;
        -s | --syncplay)
            case "$(uname -s)" in
                Darwin*) player_function="/Applications/Syncplay.app/Contents/MacOS/syncplay" ;;
                MINGW* | *Msys)
                    export PATH="$PATH":"/c/Program Files (x86)/Syncplay/"
                    player_function="syncplay.exe"
                    ;;
                *) player_function="syncplay" ;;
            esac
            ;;
        -q | --quality)
            [ $# -lt 2 ] && die "missing argument!"
            quality="$2"
            shift
            ;;
        -S | --select-nth)
            [ $# -lt 2 ] && die "missing argument!"
            index="$2"
            shift
            ;;
        -c | --continue) search=history ;;
        -d | --download)
            [ "$player_function" = "iSH" ] && iSH_DownFix="--async-dns=false"
            player_function=download
            ;;
        -D | --delete)
            : >"$histfile"
            exit 0
            ;;
        -l | --logview)
            case "$(uname -s)" in
                Darwin*) log show --predicate 'process == "logger"' ;;
                Linux*) journalctl -t ani-cli ;;
                *) die "Logger not implemented for your platform" ;;
            esac
            exit 0
            ;;
        -V | --version) version_info ;;
        -h | --help) help_info ;;
        -e | --episode | -r | --range)
            [ $# -lt 2 ] && die "missing argument!"
            ep_no="$2"
            shift
            ;;
        --dub) mode="dub"; hianime_sub_or_dub="dub" ;;
        --sub) hianime_sub_or_dub="sub" ;;
        --no-detach) no_detach=1 ;;
        --exit-after-play) exit_after_play=1 && no_detach=1 ;;
        --rofi) use_external_menu=1 ;;
        --skip) skip_intro=1 ;;
        --skip-title)
            [ $# -lt 2 ] && die "missing argument!"
            skip_title="$2"
            shift
            ;;
        -N | --nextep-countdown) search=nextep ;;
        -U | --update) update_script ;;
        --netflix) provider="netflix" ;;
        --allanime) provider="allanime" ;;
        --jiohotstar) provider="jiohotstar" ;;
        --primevideo) provider="primevideo" ;;
        --hianime) provider="hianime" ;;
        --animepahe) provider="animepahe" ;;
        --global) provider="global" ;;
        --debug) debug_mode=1 ;;
        *) query="$(printf "%s" "$query $1" | sed "s|^ ||;s| |+|g")" ;;
    esac
    shift
done
[ "$use_external_menu" = "0" ] && multi_selection_flag="${ANI_CLI_MULTI_SELECTION:-"-m"}"
[ "$use_external_menu" = "1" ] && multi_selection_flag="${ANI_CLI_MULTI_SELECTION:-"-multi-select"}"
[ "$external_menu_normal_window" = "1" ] && external_menu_args="-normal-window"
printf "\33[2K\r\033[1;34mChecking dependencies...\033[0m\n"
dep_ch "curl" "sed" "grep" || true
[ "$skip_intro" = 1 ] && (dep_ch "ani-skip" || true)
dep_ch "fzf" || true
case "$player_function" in
    debug) ;;
    download) dep_ch "ffmpeg" "aria2c" ;;
    android*) printf "\33[2K\rChecking of players on Android is disabled\n" ;;
    *iSH*) printf "\33[2K\rChecking of players on iOS is disabled\n" ;;
    flatpak_mpv) true ;; # handled out of band in where_mpv
    *) dep_ch "$player_function" ;;
esac

# searching
case "$search" in
    history)
        anime_list=$(while read -r ep_no id title; do process_hist_entry & done <"$histfile")
        wait
        [ -z "$anime_list" ] && die "No unwatched series in history!"
        [ -z "${index##*[!0-9]*}" ] && id=$(printf "%s" "$anime_list" | nl -w 2 | sed 's/^[[:space:]]//' | nth "Select anime: " | cut -f1)
        [ -z "${index##*[!0-9]*}" ] || id=$(printf "%s" "$anime_list" | sed -n "${index}p" | cut -f1)
        [ -z "$id" ] && exit 1
        title=$(printf "%s" "$anime_list" | grep "$id" | cut -f2 | sed 's/ - episode.*//')
        ep_list=$(episodes_list "$id")
        ep_no=$(printf "%s" "$anime_list" | grep "$id" | cut -f2 | sed -nE 's/.*- episode (.+)$/\1/p')
        allanime_title="$(printf "%s" "$title" | cut -d'(' -f1 | tr -d '[:punct:]')"
        ;;
    *)
        # Provider selection
        select_provider
        
        # Set search prompt based on provider
        case "$provider" in
            netflix|jiohotstar|primevideo) search_prompt="Search anime/series/movie: " ;;
            global) search_prompt="Global Search: " ;;
            *) search_prompt="Search anime: " ;;
        esac
        
        if [ "$use_external_menu" = "0" ]; then
            while [ -z "$query" ]; do
                printf "\33[2K\r\033[1;36m%s\033[0m" "$search_prompt" && read -r query
            done
        else
            [ -z "$query" ] && query=$(printf "" | external_menu "" "$search_prompt" "$external_menu_args")
            [ -z "$query" ] && exit 1
        fi
        # for checking new releases by specifying anime name
        [ "$search" = "nextep" ] && time_until_next_ep "$query"

        query=$(printf "%s" "$query" | sed "s| |+|g")
        
        # Search based on selected provider
        case "$provider" in
            netflix)
                anime_list=$(netflix_search "$query")
                ;;
            jiohotstar)
                anime_list=$(jiohotstar_search "$query")
                ;;
            primevideo)
                anime_list=$(primevideo_search "$query")
                ;;
            hianime)
                anime_list=$(hianime_search "$query")
                ;;
            animepahe)
                anime_list=$(animepahe_search "$query")
                ;;
            global)
                anime_list=$(global_search "$query")
                ;;
            *)
                anime_list=$(search_anime "$query")
                ;;
        esac
        
        [ -z "$anime_list" ] && die "No results found!"
        
        # Handle global search results (format: provider<tab>id<tab>title)
        if [ "$provider" = "global" ]; then
            # Create display list with provider prefix
            display_list=$(printf "%s" "$anime_list" | while IFS= read -r line; do
                prov=$(printf "%s" "$line" | cut -f1)
                show_id=$(printf "%s" "$line" | cut -f2)
                show_title=$(printf "%s" "$line" | cut -f3)
                printf "%s\t[%s] %s\n" "$show_id" "$prov" "$show_title"
            done)
            [ "$index" -eq "$index" ] 2>/dev/null && result=$(printf "%s" "$anime_list" | sed -n "${index}p")
            [ -z "$index" ] && selected=$(printf "%s" "$display_list" | nl -w 2 | sed 's/^[[:space:]]//' | nth "Select from results: ")
            [ -z "$selected" ] && exit 1
            # Extract provider from selection
            provider=$(printf "%s" "$selected" | sed -nE 's/.*\[([^]]+)\].*/\1/p')
            id=$(printf "%s" "$selected" | cut -f1)
            title=$(printf "%s" "$selected" | cut -f2 | sed 's/\[[^]]*\] //')
        else
            [ "$index" -eq "$index" ] 2>/dev/null && result=$(printf "%s" "$anime_list" | sed -n "${index}p")
            [ -z "$index" ] && result=$(printf "%s" "$anime_list" | nl -w 2 | sed 's/^[[:space:]]//' | nth "Select anime: ")
            [ -z "$result" ] && exit 1
            title=$(printf "%s" "$result" | cut -f2)
            id=$(printf "%s" "$result" | cut -f1)
        fi
        
        allanime_title="$(printf "%s" "$title" | cut -d'(' -f1 | tr -d '[:punct:]')"
        
        # Get episodes based on provider
        case "$provider" in
            netflix)
                ep_list=$(netflix_episodes_list "$id")
                ;;
            jiohotstar)
                ep_list=$(jiohotstar_episodes_list "$id")
                ;;
            primevideo)
                ep_list=$(primevideo_episodes_list "$id")
                ;;
            hianime)
                ep_list=$(hianime_episodes_list "$id")
                ;;
            animepahe)
                ep_list=$(animepahe_episodes_list "$id")
                ;;
            *)
                ep_list=$(episodes_list "$id")
                ;;
        esac
        
        [ -z "$ep_no" ] && ep_no=$(printf "%s" "$ep_list" | nth "Select episode: " "$multi_selection_flag")
        [ -z "$ep_no" ] && exit 1
        ;;
esac
[ "$skip_intro" = 1 ] && mal_id="$(ani-skip -q "${skip_title:-${title}}")"

# moves the cursor up one line and clears that line
tput cuu1 && tput el
# stores the position of cursor
tput sc

# playback & loop
play
[ "$player_function" = "download" ] || [ "$player_function" = "debug" ] && exit 0

# Wait for player to start and video to begin loading
printf "\33[2K\r\033[1;33m Waiting for video to start...\033[0m" >&2
sleep 3

# Clear and show menu header
printf "\33[2K\r\033[1;32m Player opened successfully!\033[0m\n" >&2
printf "\033[1;36mNow playing: %s - Episode %s\033[0m\n" "$title" "$ep_no" >&2
printf "\033[1;90mUse the menu below to control playback:\033[0m\n\n" >&2

# Build menu options based on provider
if [ "$provider" = "netflix" ] || [ "$provider" = "jiohotstar" ] || [ "$provider" = "primevideo" ]; then
    menu_options="next\nreplay\nprevious\nselect\nchange_quality\nchange_audio\nchange_subtitle\nquit"
elif [ "$provider" = "hianime" ] || [ "$provider" = "animepahe" ]; then
    menu_options="next\nreplay\nprevious\nselect\nchange_quality\nchange_sub_dub\nquit"
else
    menu_options="next\nreplay\nprevious\nselect\nchange_quality\nquit"
fi

while cmd=$(printf "$menu_options" | nth "Playing episode $ep_no of $title... "); do
    case "$cmd" in
        next) ep_no=$(printf "%s" "$ep_list" | sed -n "/^${ep_no}$/{n;p;}") 2>/dev/null ;;
        replay) episode="$replay" ;;
        previous) ep_no=$(printf "%s" "$ep_list" | sed -n "/^${ep_no}$/{g;1!p;};h") 2>/dev/null ;;
        select) ep_no=$(printf "%s" "$ep_list" | nth "Select episode: " "$multi_selection_flag") ;;
        change_quality)
            if [ "$provider" = "animepahe" ]; then
                # AnimePahe: use stored sources with full quality/audio info
                if [ -n "$animepahe_sources" ]; then
                    # Prepare launcher input: number url label
                    idx=1
                    launcher_input=""
                    while IFS=$'\t' read -r res url audio label; do
                        [ -n "$label" ] && launcher_input="${launcher_input}${idx}\t${url}\t${label}\n"
                        idx=$((idx + 1))
                    done << EOF
$(printf "%b" "$animepahe_sources")
EOF
                    selected=$(printf "%b" "$launcher_input" | nth "Select quality: ")
                    if [ -n "$selected" ]; then
                        new_kwik_url=$(printf "%s" "$selected" | cut -f1)
                        new_quality=$(printf "%s" "$selected" | cut -f2)
                        # Extract new m3u8
                        printf "\33[2K\r\033[1;34mExtracting video URL from Kwik (%s)...\033[0m\n" "$new_quality" >&2
                        new_m3u8=$(animepahe_extract_kwik "$new_kwik_url")
                        if [ -n "$new_m3u8" ]; then
                            episode="$new_m3u8"
                            printf "\033[1;32mQuality changed to: %s\033[0m\n" "$new_quality" >&2
                        else
                            printf "\033[1;31mFailed to extract video URL\033[0m\n" >&2
                            continue
                        fi
                    else
                        continue
                    fi
                else
                    printf "\033[1;31mNo quality options available\033[0m\n" >&2
                    continue
                fi
            else
                new_quality="$(printf "%s" "$links" | launcher | cut -d\> -f1)"
                select_quality "$new_quality"
            fi
            ;;
        change_audio)
            # Use available audio languages from current content
            if [ "$provider" = "netflix" ]; then
                available_audio="$netflix_available_audio"
            elif [ "$provider" = "jiohotstar" ]; then
                available_audio="$jiohotstar_available_audio"
            elif [ "$provider" = "primevideo" ]; then
                available_audio="$primevideo_available_audio"
            else
                available_audio=""
            fi
            if [ -z "$available_audio" ]; then
                printf "\033[1;31mNo audio tracks available\033[0m\n" >&2
                continue
            fi
            new_audio=$(printf "%s" "$available_audio" | nth "Select audio language: ")
            if [ -n "$new_audio" ]; then
                if [ "$provider" = "netflix" ]; then
                    netflix_selected_audio="$new_audio"
                    netflix_audio_file="--alang=${new_audio}"
                elif [ "$provider" = "jiohotstar" ]; then
                    jiohotstar_selected_audio="$new_audio"
                    jiohotstar_audio_file="--alang=${new_audio}"
                elif [ "$provider" = "primevideo" ]; then
                    primevideo_selected_audio="$new_audio"
                    primevideo_audio_file="--alang=${new_audio}"
                fi
                printf "\033[1;32mAudio changed to: %s\033[0m\n" "$new_audio" >&2
                episode="$replay"
            else
                continue
            fi
            ;;
        change_subtitle)
            # Use available subtitle languages from current content
            if [ "$provider" = "netflix" ]; then
                available_subs="$netflix_available_subs"
                playlist_response="$netflix_playlist_response"
            elif [ "$provider" = "jiohotstar" ]; then
                available_subs="$jiohotstar_available_subs"
                playlist_response="$jiohotstar_playlist_response"
            elif [ "$provider" = "primevideo" ]; then
                available_subs="$primevideo_available_subs"
                playlist_response="$primevideo_playlist_response"
            else
                available_subs=""
                playlist_response=""
            fi
            if [ -z "$available_subs" ]; then
                sub_options="Off"
            else
                sub_options=$(printf "%s\nOff" "$available_subs")
            fi
            new_sub=$(printf "%s" "$sub_options" | nth "Select subtitle language: ")
            if [ "$new_sub" = "Off" ]; then
                subs_flag=""
                subtitle=""
                printf "\033[1;32mSubtitles disabled\033[0m\n" >&2
                episode="$replay"
            elif [ -n "$new_sub" ]; then
                # Find the subtitle URL for the selected language
                new_sub_url=$(printf "%s" "$playlist_response" | tr '{' '\n' | grep '"kind":"captions"' | grep "\"label\":\"$new_sub\"" | head -1 | grep -oE '"file":"[^"]+"' | cut -d'"' -f4 | sed 's|\\|/|g')
                if [ -n "$new_sub_url" ]; then
                    case "$new_sub_url" in
                        http*) subtitle="$new_sub_url" ;;
                        //*) subtitle="https:$new_sub_url" ;;
                        /*) subtitle="https://subs.nfmirrorcdn.top$new_sub_url" ;;
                    esac
                    subtitle=$(printf "%s" "$subtitle" | sed 's|\(https://[^/]*\)//*|\1/|g; s|/\{2,\}|/|g')
                    subs_flag="--sub-file=$subtitle"
                    printf "\033[1;32mSubtitle changed to: %s\033[0m\n" "$new_sub" >&2
                fi
                episode="$replay"
            else
                continue
            fi
            ;;
        change_sub_dub)
            # Toggle between sub and dub for HiAnime and AnimePahe
            if [ "$provider" = "hianime" ]; then
                current_mode="$hianime_sub_or_dub"
                if [ "$current_mode" = "sub" ]; then
                    new_mode=$(printf "sub (current)\ndub" | nth "Select audio type: " | sed 's/ (current)//')
                else
                    new_mode=$(printf "sub\ndub (current)" | nth "Select audio type: " | sed 's/ (current)//')
                fi
                if [ -n "$new_mode" ] && [ "$new_mode" != "$current_mode" ]; then
                    hianime_sub_or_dub="$new_mode"
                    printf "\033[1;32mSwitched to: %s\033[0m\n" "$new_mode" >&2
                    # Re-fetch episode with new sub/dub preference
                    unset episode
                else
                    continue
                fi
            elif [ "$provider" = "animepahe" ]; then
                # AnimePahe: show available audio options from current sources
                if [ -n "$animepahe_sources" ]; then
                    # Filter sources to show only sub or dub options
                    current_mode="$animepahe_sub_or_dub"
                    has_sub=$(printf "%b" "$animepahe_sources" | grep -c $'\tjpn\t')
                    has_dub=$(printf "%b" "$animepahe_sources" | grep -c $'\teng\t')
                    
                    if [ "$has_sub" -gt 0 ] && [ "$has_dub" -gt 0 ]; then
                        # Both available - show selector
                        if [ "$current_mode" = "sub" ]; then
                            new_mode=$(printf "sub (current)\ndub" | nth "Select audio type: " | sed 's/ (current)//')
                        else
                            new_mode=$(printf "sub\ndub (current)" | nth "Select audio type: " | sed 's/ (current)//')
                        fi
                        if [ -n "$new_mode" ] && [ "$new_mode" != "$current_mode" ]; then
                            # Find a source with the new audio type
                            if [ "$new_mode" = "sub" ]; then
                                audio_filter="jpn"
                            else
                                audio_filter="eng"
                            fi
                            # Get first matching source with same or best quality
                            new_source=$(printf "%b" "$animepahe_sources" | grep $'\t'"$audio_filter"$'\t' | sort -t$'\t' -k1 -rn | head -1)
                            if [ -n "$new_source" ]; then
                                new_kwik_url=$(printf "%s" "$new_source" | cut -f2)
                                new_quality=$(printf "%s" "$new_source" | cut -f4)
                                printf "\33[2K\r\033[1;34mExtracting video URL from Kwik (%s)...\033[0m\n" "$new_quality" >&2
                                new_m3u8=$(animepahe_extract_kwik "$new_kwik_url")
                                if [ -n "$new_m3u8" ]; then
                                    episode="$new_m3u8"
                                    animepahe_sub_or_dub="$new_mode"
                                    printf "\033[1;32mSwitched to: %s (%s)\033[0m\n" "$new_mode" "$new_quality" >&2
                                else
                                    printf "\033[1;31mFailed to extract video URL\033[0m\n" >&2
                                    continue
                                fi
                            else
                                printf "\033[1;31mNo %s audio available\033[0m\n" "$new_mode" >&2
                                continue
                            fi
                        else
                            continue
                        fi
                    elif [ "$has_dub" -gt 0 ]; then
                        printf "\033[1;33mOnly dub audio available for this episode\033[0m\n" >&2
                        continue
                    else
                        printf "\033[1;33mOnly sub audio available for this episode\033[0m\n" >&2
                        continue
                    fi
                else
                    printf "\033[1;31mNo audio options available\033[0m\n" >&2
                    continue
                fi
            else
                printf "\033[1;31mSub/Dub toggle only available for HiAnime and AnimePahe\033[0m\n" >&2
                continue
            fi
            ;;
        *) exit 0 ;;
    esac
    [ -z "$ep_no" ] && die "Out of range"
    play
done

# ani-cli
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Project repository: https://github.com/pystardust/ani-cli
